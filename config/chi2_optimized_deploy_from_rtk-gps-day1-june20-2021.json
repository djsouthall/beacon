{
    "description": "Automatically generated description for a calibration starting from deploy_index: /home/dsouthall/projects/beacon/beacon/config/rtk-gps-day1-june20-2021_2021-07-01_15-30-32p620236.json.  This config has updated vpol values based on a calibration that was performed.  Initial description: Automatically generated description for a calibration starting from deploy_index: /home/dsouthall/projects/beacon/beacon/config/rtk-gps-day1-june20-2021.json.  This config has updated hpol values based on a calibration that was performed.  Initial description: Measurements made on June 20th using NTrip corrected RTK GPS and UNAVCO P652 data.  The expected accuracy of this data is on the scale of cm.  The listed altitudes are in WGS-84 and are adjusted by adding a height of 5ft8in, (1.7272m) from the actual measurements to account for the offset from the GPS patch antenna positions and the antennas at the top.  This is NOT the positions of the antennas as installed after this date (though likely very close), but rather of the masts before they were disassembled.  Some of the masts may have shifted from when their data was taken.  Cable delays come from the 2019 october deployment measurements and are not altered by a chi squared caliration effort.",
    "additional_text": "'''\nThis script assumes the antenna positions have already roughly been set/determined\nusing find_phase_centers.py  .  It will assume these as starting points of the antennas\nand then vary all 4 of their locations to match measured time delays from RFI sources in the valley. \n'''\n\n#General Imports\nimport numpy\nimport itertools\nimport os\nimport sys\nimport csv\nimport scipy\nimport scipy.interpolate\nimport pymap3d as pm\nfrom iminuit import Minuit\nimport inspect\nimport h5py\n\n#Personal Imports\nfrom beaconroot.examples.beacon_data_reader import Reader #Must be imported before matplotlib or else plots don't load.\nfrom beacon.tools.data_handler import createFile, getTimes\nimport beacon.tools.station as bc\nimport beacon.tools.info as info\nimport beacon.tools.get_plane_tracks as pt\nfrom beacon.tools.fftmath import TimeDelayCalculator\nfrom beacon.tools.data_slicer import dataSlicerSingleRun\nfrom beacon.tools.correlator import Correlator\nimport beacon.tools.config_reader as bcr\n\n\n#Plotting Imports\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nfrom mpl_toolkits.mplot3d import Axes3D\n\n\n#Settings\nfrom pprint import pprint\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nplt.ion()\ndatapath = os.environ['BEACON_DATA']\n\nn = 1.0003 #Index of refraction of air  #Should use https://www.itu.int/dms_pubrec/itu-r/rec/p/R-REC-P.453-11-201507-S!!PDF-E.pdf \nc = 299792458/n #m/s\n\n#Settings for the current hilbert and \"normal filtered waveforms\"\n\n#Pre measured time delays from pulsing sources.\n#All use the following filters\n# final_corr_length = 2**17 #Should be a factor of 2 for fastest performance\n# apply_phase_response = True\n\n# crit_freq_low_pass_MHz = [100,75,75,75,75,75,75,75]\n# low_pass_filter_order = [8,12,14,14,14,14,14,14]\n\n# crit_freq_high_pass_MHz = None#30#None#50\n# high_pass_filter_order = None#5#None#8\n\n# sine_subtract = True\n# sine_subtract_min_freq_GHz = 0.03\n# sine_subtract_max_freq_GHz = 0.09\n# sine_subtract_percent = 0.03\n\n# plot_filters = False\n# plot_multiple = False\n\n# hilbert = [VARIES, LABELED BELOW]\n# align_method = 0\n\n# shorten_signals = True\n# shorten_thresh = 0.7\n# shorten_delay = 10.0\n# shorten_length = 90.0\n\n#Settings for by eye and for when using vpol to determine hpol:\n\n# crit_freq_low_pass_MHz = [80,70,70,70,70,70,60,70] #Filters here are attempting to correct for differences in signals from pulsers.\n# low_pass_filter_order = [0,8,8,8,10,8,3,8]\n\n# crit_freq_high_pass_MHz = 65\n# high_pass_filter_order = 12\n\n# sine_subtract = True\n# sine_subtract_min_freq_GHz = 0.03\n# sine_subtract_max_freq_GHz = 0.13\n# sine_subtract_percent = 0.03\n\n\nprint('IF USING TIME DELAYS FOR PULSERS, I TRUST CURRENT BY EYE VERSION')\n\n# Site 1, Run 1507\n#Using normal filtered waveforms\n# site1_measured_time_delays_hpol =  [((0, 1), -54.73863562760832), ((0, 2), 91.15858599870768), ((0, 3), 2.2128385205326464), ((1, 2), 145.8794202783432), ((1, 3), 70.83219696885855), ((2, 3), -75.0806062508086)]\n# site1_measured_time_delays_errors_hpol =  [((0, 1), 0.06502425258486934), ((0, 2), 0.04578149270315245), ((0, 3), 0.05552697804026172), ((1, 2), 0.04285045065819871), ((1, 3), 0.0502413434940142), ((2, 3), 0.03943499232368893)]\n# site1_measured_time_delays_vpol =  [((0, 1), -41.34298309480882), ((0, 2), 98.41416470888946), ((0, 3), 32.9834991717602), ((1, 2), 139.76496652601807), ((1, 3), 74.35728021223598), ((2, 3), -65.41722156408288)]\n# site1_measured_time_delays_errors_vpol =  [((0, 1), 0.042884363603573825), ((0, 2), 0.0441559772370423), ((0, 3), 0.03848571442688579), ((1, 2), 0.04704966892964731), ((1, 3), 0.04630379764018927), ((2, 3), 0.045227795080871123)]\n\n#By eye with heavy filtering\n# site1_measured_time_delays_hpol =  [((0, 1), -54.969833107118845), ((0, 2), 87.14009967681076), ((0, 3), 24.00177447738297), ((1, 2), 142.14047250017052), ((1, 3), 79.05998159730048), ((2, 3), -63.10231911641529)]\n# site1_measured_time_delays_errors_hpol =  [((0, 1), 0.05397614123500611), ((0, 2), 0.04512309121971968), ((0, 3), 0.05204283012142891), ((1, 2), 0.03087221688563602), ((1, 3), 0.032053827917602244), ((2, 3), 0.028770235190528414)]\n# site1_measured_time_delays_vpol =  [((0, 1), -38.0395259095481), ((0, 2), 101.66276202065728), ((0, 3), 36.28366947068722), ((1, 2), 139.71981822328297), ((1, 3), 74.38132870251398), ((2, 3), -65.37132308735707)]\n# site1_measured_time_delays_errors_vpol =  [((0, 1), 0.03821252883631024), ((0, 2), 0.03683462360960683), ((0, 3), 0.0371499730741353), ((1, 2), 0.04214783336728045), ((1, 3), 0.03760640106500705), ((2, 3), 0.03780978324309525)]\n#By eye unfiltered\nsite1_measured_time_delays_hpol =  [((0, 1), -40.31873095761775), ((0, 2), 105.45784514533067), ((0, 3), 30.135050738939075), ((1, 2), 145.61788076163322), ((1, 3), 70.58430198762721), ((2, 3), -75.18303704634458)]\nsite1_measured_time_delays_errors_hpol =  [((0, 1), 0.05390602875058418), ((0, 2), 0.044986501385526165), ((0, 3), 0.04766074318950998), ((1, 2), 0.028887890879186494), ((1, 3), 0.03252021044637105), ((2, 3), 0.03225428496045381)]\nsite1_measured_time_delays_vpol =  [((0, 1), -37.997470132440384), ((0, 2), 101.68917969316817), ((0, 3), 36.40724396999149), ((1, 2), 139.68684427937058), ((1, 3), 74.50112508391489), ((2, 3), -65.25487641338805)]\nsite1_measured_time_delays_errors_vpol =  [((0, 1), 0.03011827820152272), ((0, 2), 0.03019736343475925), ((0, 3), 0.031375107623472516), ((1, 2), 0.032447697682718275), ((1, 3), 0.03109667967812645), ((2, 3), 0.031271228554630597)]\n\n# Site 2, Run 1509\n#Using normal filtered waveforms\n# site2_measured_time_delays_hpol =  [((0, 1), -96.52211468189127), ((0, 2), 26.44864606474854), ((0, 3), -72.54565055659056), ((1, 2), 123.1494860790839), ((1, 3), 38.24363584514595), ((2, 3), -85.05175803438193)]\n# site2_measured_time_delays_errors_hpol =  [((0, 1), 0.08249898683406354), ((0, 2), 0.07575714414002656), ((0, 3), 0.07207545260984918), ((1, 2), 0.07601506755721471), ((1, 3), 0.08100775284944606), ((2, 3), 0.04962571327194129)]\n# site2_measured_time_delays_vpol =  [((0, 1), -83.19953242338167), ((0, 2), 33.788067132019236), ((0, 3), -41.64972472448962), ((1, 2), 116.94909535917708), ((1, 3), 41.5594035217089), ((2, 3), -75.40642816197486)]\n# site2_measured_time_delays_errors_vpol =  [((0, 1), 0.0587727059708651), ((0, 2), 0.06416229949778407), ((0, 3), 0.057996504388612015), ((1, 2), 0.06429783537463728), ((1, 3), 0.05940387444310559), ((2, 3), 0.05479525148189039)]\n\n#Starting with vpol time delays for hpol\n# site2_measured_time_delays_hpol =  [((0, 1), -83.4350299273764), ((0, 2), 35.98735001057835), ((0, 3), -37.227818605847155), ((1, 2), 119.48454452242105), ((1, 3), 46.314350011875135), ((2, 3), -73.19628700828557)]\n# site2_measured_time_delays_errors_hpol =  [((0, 1), 0.08100363991429034), ((0, 2), 0.08840029523525751), ((0, 3), 0.07553940454510318), ((1, 2), 0.06814144543927382), ((1, 3), 0.05585941670256171), ((2, 3), 0.04175515290975236)]\n# site2_measured_time_delays_vpol =  [((0, 1), -79.9254869986498), ((0, 2), 36.95016873421155), ((0, 3), -38.37130874987727), ((1, 2), 116.82930650572263), ((1, 3), 41.60022844836235), ((2, 3), -75.29534858596858)]\n# site2_measured_time_delays_errors_vpol =  [((0, 1), 0.05470476738778757), ((0, 2), 0.05120618401181174), ((0, 3), 0.04941877318633543), ((1, 2), 0.061857288229529614), ((1, 3), 0.05130304646372132), ((2, 3), 0.04567102070600878)]\n#By eye with heavy filtering\n# site2_measured_time_delays_hpol =  [((0, 1), -96.97522838255696), ((0, 2), 8.739083570682284), ((0, 3), -50.80788386992672), ((1, 2), 105.83015717556633), ((1, 3), 46.314350011875135), ((2, 3), -73.19628700828557)]\n# site2_measured_time_delays_errors_hpol =  [((0, 1), 0.06347605396637605), ((0, 2), 0.06380476954335818), ((0, 3), 0.06187583322961239), ((1, 2), 0.06269502641508909), ((1, 3), 0.05585941670256171), ((2, 3), 0.04175515290975236)]\n# site2_measured_time_delays_vpol =  [((0, 1), -79.92548699865343), ((0, 2), 36.950168734211644), ((0, 3), -38.37130874987719), ((1, 2), 116.82930650572267), ((1, 3), 41.60022844836235), ((2, 3), -75.29534858596858)]\n# site2_measured_time_delays_errors_vpol =  [((0, 1), 0.05470476739678275), ((0, 2), 0.05120618401166019), ((0, 3), 0.04941877318949003), ((1, 2), 0.061857288229529614), ((1, 3), 0.05130304646372132), ((2, 3), 0.04567102070600878)]\n#By eye with no filtering\nsite2_measured_time_delays_hpol =  [((0, 1), -82.36300952477696), ((0, 2), 40.532241178254594), ((0, 3), -44.62321034858617), ((1, 2), 122.63983003115614), ((1, 3), 37.84008150548918), ((2, 3), -85.10254711335975)]\nsite2_measured_time_delays_errors_hpol =  [((0, 1), 0.06805633356582455), ((0, 2), 0.06374115194036371), ((0, 3), 0.061932184861914215), ((1, 2), 0.05385988241825421), ((1, 3), 0.06333087652874915), ((2, 3), 0.04576242749045018)]\nsite2_measured_time_delays_vpol =  [((0, 1), -79.95386249566438), ((0, 2), 36.76801256475748), ((0, 3), -38.345785064895686), ((1, 2), 116.64786424329235), ((1, 3), 41.7113458359634), ((2, 3), -75.08797122311996)]\nsite2_measured_time_delays_errors_vpol =  [((0, 1), 0.042075284218763505), ((0, 2), 0.04115999677119886), ((0, 3), 0.03731577983391688), ((1, 2), 0.04697815701549882), ((1, 3), 0.037159371366881265), ((2, 3), 0.03363016431350404)]\n\n# Site 3, Run 1511\nsite3_measured_time_delays_hilbert_errors_vpol =  [((0, 1), 0.03654878810011606), ((0, 2), 0.044076823274307404), ((0, 3), 0.04115323593715623), ((1, 2), 0.039281585194972476), ((1, 3), 0.04240838492773853), ((2, 3), 0.04449409255674249)]\n\n#Using normal filtered waveforms\n# site3_measured_time_delays_hpol =  [((0, 1), -109.18511106059067), ((0, 2), -158.10857451624145), ((0, 3), -191.41010115062258), ((1, 2), -48.875126824337244), ((1, 3), -82.20492349641286), ((2, 3), -33.23554377320981)]\n# site3_measured_time_delays_errors_hpol =  [((0, 1), 0.052428389377522186), ((0, 2), 0.07196071815111829), ((0, 3), 0.057841508523156095), ((1, 2), 0.05836839659836438), ((1, 3), 0.06144960035833733), ((2, 3), 0.08874905433961774)]\n# site3_measured_time_delays_vpol =  [((0, 1), -95.30265032203047), ((0, 2), -150.3612627337264), ((0, 3), -175.88155062409197), ((1, 2), -55.06965132126639), ((1, 3), -80.55266965411217), ((2, 3), -25.524227125491926)]\n# site3_measured_time_delays_errors_vpol =  [((0, 1), 0.03654878810011606), ((0, 2), 0.044076823274307404), ((0, 3), 0.04115323593715623), ((1, 2), 0.039281585194972476), ((1, 3), 0.04240838492773853), ((2, 3), 0.04449411155669218)]\n\n#By eye with heavy filtering\n# site3_measured_time_delays_hpol =  [((0, 1), -109.34183150535519), ((0, 2), -162.03789621141365), ((0, 3), -183.21756927506613), ((1, 2), -52.62823300992422), ((1, 3), -73.79391408829574), ((2, 3), -21.183744364934398)]\n# site3_measured_time_delays_errors_hpol =  [((0, 1), 0.04265253188274841), ((0, 2), 0.06423203676109482), ((0, 3), 0.04702481712409536), ((1, 2), 0.04856625123399987), ((1, 3), 0.04080526421433228), ((2, 3), 0.05989498787455408)]\n# site3_measured_time_delays_vpol =  [((0, 1), -92.01039256757632), ((0, 2), -147.11633863997915), ((0, 3), -172.54667944061194), ((1, 2), -55.10074275670341), ((1, 3), -80.47338613712525), ((2, 3), -25.426023438675795)]\n# site3_measured_time_delays_errors_vpol =  [((0, 1), 0.03342246038492944), ((0, 2), 0.03848447654781584), ((0, 3), 0.039030703182496955), ((1, 2), 0.036584465848776934), ((1, 3), 0.037736362321036596), ((2, 3), 0.038955535978780334)]\n\n#By eye with no filtering\nsite3_measured_time_delays_hpol =  [((0, 1), -94.60387463826103), ((0, 2), -143.57675835202508), ((0, 3), -177.08153009135634), ((1, 2), -49.07507885269845), ((1, 3), -82.25996187697748), ((2, 3), -33.23172107457927)]\nsite3_measured_time_delays_errors_hpol =  [((0, 1), 0.050722621463835826), ((0, 2), 0.0668571644522086), ((0, 3), 0.054427178270967415), ((1, 2), 0.0460384615661204), ((1, 3), 0.03794985949273057), ((2, 3), 0.06075860733801835)]\nsite3_measured_time_delays_vpol =  [((0, 1), -92.0411188138037), ((0, 2), -147.12574991663104), ((0, 3), -172.41237810521784), ((1, 2), -55.093716852263405), ((1, 3), -80.26283429217344), ((2, 3), -25.26536153179327)]\nsite3_measured_time_delays_errors_vpol =  [((0, 1), 0.026686488662462645), ((0, 2), 0.029657613098382718), ((0, 3), 0.03176185523762114), ((1, 2), 0.029839183454581412), ((1, 3), 0.02891810009497307), ((2, 3), 0.030919678248785214)]\n\n#Starting with vpol time delays for hpol\n# site3_measured_time_delays_hpol =  [((0, 1), -96.09672657178147), ((0, 2), -148.73076067727396), ((0, 3), -169.93956133124348), ((1, 2), -52.62823300992422), ((1, 3), -73.79391408829574), ((2, 3), -21.183744364934398)]\n# site3_measured_time_delays_errors_hpol =  [((0, 1), 0.039552441264012354), ((0, 2), 0.06278263246667376), ((0, 3), 0.047063796245871106), ((1, 2), 0.04856625123399987), ((1, 3), 0.04080526421433228), ((2, 3), 0.05989498787455408)]\n# site3_measured_time_delays_vpol =  [((0, 1), -92.0103925675772), ((0, 2), -147.11633863997926), ((0, 3), -172.54667944061526), ((1, 2), -55.10074275670341), ((1, 3), -80.47338613712525), ((2, 3), -25.426023438675795)]\n# site3_measured_time_delays_errors_vpol =  [((0, 1), 0.03342246036574039), ((0, 2), 0.03848447653883523), ((0, 3), 0.03903070321188336), ((1, 2), 0.036584465848776934), ((1, 3), 0.037736362321036596), ((2, 3), 0.038955535978780334)]\n\n\n\n\n\nprint('IF USING HILBERT TIME DELAYS FOR PULSERS, I DONT TRUST CURRENT VERSION')\n\n# Site 1, Run 1507\n#Using hilbert enevelopes:\nsite1_measured_time_delays_hilbert_hpol =  [((0, 1), -58.987476762558636), ((0, 2), 85.65448689743364), ((0, 3), 8.320951597921127), ((1, 2), 144.48438341182535), ((1, 3), 67.16676381542445), ((2, 3), -77.3644536438967)]\nsite1_measured_time_delays_hilbert_errors_hpol =  [((0, 1), 0.8377448773505135), ((0, 2), 0.3594185551190815), ((0, 3), 0.594635989964824), ((1, 2), 0.7881229445755795), ((1, 3), 0.655179094065839), ((2, 3), 0.5535397424928563)]\nsite1_measured_time_delays_hilbert_vpol =  [((0, 1), -41.7904293292381), ((0, 2), 97.99566415134592), ((0, 3), 32.98832571271674), ((1, 2), 139.79330184195436), ((1, 3), 74.75836427079234), ((2, 3), -65.04301010744241)]\nsite1_measured_time_delays_hilbert_errors_vpol =  [((0, 1), 0.4735699881401701), ((0, 2), 0.4590523544465075), ((0, 3), 0.42013177070803437), ((1, 2), 0.6012971718190752), ((1, 3), 0.47273363718795347), ((2, 3), 0.4704350387698477)]\n\n# Site 2, Run 1509\n#Using hilbert envelopes:\nsite2_measured_time_delays_hilbert_hpol =  [((0, 1), -100.60440248833073), ((0, 2), 18.252306266584625), ((0, 3), -68.1176724682709), ((1, 2), 118.43971845333104), ((1, 3), 32.27161618415478), ((2, 3), -86.74537359631644)]\nsite2_measured_time_delays_hilbert_errors_hpol =  [((0, 1), 0.8957178121617457), ((0, 2), 1.016165870957765), ((0, 3), 0.7663702873722121), ((1, 2), 1.400179720774765), ((1, 3), 1.0146094407051107), ((2, 3), 0.9757739190044133)]\nsite2_measured_time_delays_hilbert_vpol =  [((0, 1), -83.84057479839511), ((0, 2), 29.220940734890714), ((0, 3), -42.61904475811045), ((1, 2), 113.34806469515324), ((1, 3), 41.375706449073355), ((2, 3), -71.86012025765733)]\nsite2_measured_time_delays_hilbert_errors_vpol =  [((0, 1), 0.6408498537052976), ((0, 2), 0.6485697868214796), ((0, 3), 0.5952727184008998), ((1, 2), 0.7658668502667069), ((1, 3), 0.6880201767149771), ((2, 3), 0.6428620412909642)]\n\n# Site 3, Run 1511\n#Using hilbert envelopes:\nsite3_measured_time_delays_hilbert_hpol =  [((0, 1), -109.18511106059067), ((0, 2), -158.10857451624145), ((0, 3), -191.41010115062258), ((1, 2), -48.875126824337244), ((1, 3), -82.20492349641286), ((2, 3), -33.23548270662396)]\nsite3_measured_time_delays_hilbert_errors_hpol =  [((0, 1), 0.052428389377522186), ((0, 2), 0.07196071815111829), ((0, 3), 0.057841508523156095), ((1, 2), 0.05836839659836438), ((1, 3), 0.06144960035833733), ((2, 3), 0.08874875693196994)]\nsite3_measured_time_delays_hilbert_vpol =  [((0, 1), -95.30265032203047), ((0, 2), -150.3612627337264), ((0, 3), -175.88155062409197), ((1, 2), -55.06965132126639), ((1, 3), -80.55266965411217), ((2, 3), -25.524379719980214)]\nsite3_measured_time_delays_hilbert_errors_vpol =  [((0, 1), 0.03654878810011606), ((0, 2), 0.044076823274307404), ((0, 3), 0.04115323593715623), ((1, 2), 0.039281585194972476), ((1, 3), 0.04240838492773853), ((2, 3), 0.04449409255674249)]\n\ncw_sources = {}\n\ntime_delay_dict = {'hpol':{'[0, 1]' : [-77.6], '[0, 2]': [95.76], '[0, 3]': [-15.82], '[1, 2]': [173.4], '[1, 3]': [61.77], '[2, 3]': [-111.6]}}\n\ncw_sources['khsv'] = {}\ncw_sources['khsv']['latlonel'] = numpy.array([36.008611, -115.005556, 3316*0.3048 + 10])\nperiod = 17.54 #ns (57 MHz)\ncw_sources['khsv']['time_delay_dict'] = {'hpol':{'[0, 1]'   :[ -77.6           ],\\\n                                                 '[0, 2]'   :[ 95.76  - period ],\\\n                                                 '[0, 3]'   :[ -15.82          ],\\\n                                                 '[1, 2]'   :[ 173.4  - period ],\\\n                                                 '[1, 3]'   :[ 61.77           ],\\\n                                                 '[2, 3]'   :[ -111.6 + period ]}}\n# cw_sources['khsv']['time_delay_dict'] = {'hpol':{'[0, 1]'   : -77.6     + period*(numpy.arange(5) - 2),\\\n#                                                  '[0, 2]'   : 95.76     + period*(numpy.arange(5) - 2),\\\n#                                                  '[0, 3]'   : -15.82    + period*(numpy.arange(5) - 2),\\\n#                                                  '[1, 2]'   : 173.4     + period*(numpy.arange(5) - 2),\\\n#                                                  '[1, 3]'   : 61.77     + period*(numpy.arange(5) - 2),\\\n#                                                  '[2, 3]'   : -111.6    + period*(numpy.arange(5) - 2)}}\n#cw_sources['khsv']['time_delay_dict'] = {'hpol':{'[0, 1]' : [-77.6], '[0, 2]': [95.76], '[0, 3]': [-15.82], '[1, 2]': [173.4], '[1, 3]': [61.77], '[2, 3]': [-111.6]}}\n#cw_sources['khsv']['time_delay_dict'] = {'hpol':{'[0, 1]' : [-77.6], '[0, 2]': [95.76 + period, 95.76, 95.76 - period,  95.76 - 2*period], '[0, 3]': [-15.82], '[1, 2]': [173.4 + period, 173.4, 173.4 - period,  173.4 - 2*period], '[1, 3]': [61.77], '[2, 3]': [-111.6 + 2*period, -111.6 + period, -111.6, -111.6 - period, -111.6 - 2*period]}}\n\ncw_sources['khsv']['data_slicer_dict'] = {'std_h':[0.5,1.5],'std_v':[0.5,0.9],'snr_v':[8.0,9.0]}\ncw_sources['khsv']['data_slicer_run'] = 1650\n\ncable_delays = info.loadCableDelays(return_raw=True)\ncable_delay_differences = cable_delays['hpol'] - cable_delays['vpol']\n\n#Assuming the hpol time delays are measured accurately and so are our cable delays, this will give what we would predict the measured (raw without accounting for cable delays) time delays of the vpol to be.  I do this to attempt to use the hpol time delays in a vpol calibration.\ncw_sources['khsv']['time_delay_dict']['vpol'] = {   '[0, 1]' : [-77.6   - (cable_delays['hpol'][0] - cable_delays['hpol'][1]) + (cable_delays['vpol'][0] - cable_delays['vpol'][1]) ],\\\n                                                    '[0, 2]' : [95.76   - (cable_delays['hpol'][0] - cable_delays['hpol'][2]) + (cable_delays['vpol'][0] - cable_delays['vpol'][2]) ],\\\n                                                    '[0, 3]' : [-15.82  - (cable_delays['hpol'][0] - cable_delays['hpol'][3]) + (cable_delays['vpol'][0] - cable_delays['vpol'][3]) ],\\\n                                                    '[1, 2]' : [173.4   - (cable_delays['hpol'][1] - cable_delays['hpol'][2]) + (cable_delays['vpol'][1] - cable_delays['vpol'][2]) ],\\\n                                                    '[1, 3]' : [61.77   - (cable_delays['hpol'][1] - cable_delays['hpol'][3]) + (cable_delays['vpol'][1] - cable_delays['vpol'][3]) ],\\\n                                                    '[2, 3]' : [-111.6  - (cable_delays['hpol'][2] - cable_delays['hpol'][3]) + (cable_delays['vpol'][2] - cable_delays['vpol'][3]) ]}\n\n\n\n\n\nif __name__ == '__main__':\n    try:\n        plt.close('all')\n        if len(sys.argv) == 2:\n            if str(sys.argv[1]) in ['vpol', 'hpol']:\n                mode = str(sys.argv[1])\n            else:\n                print('Given mode not in options.  Defaulting to hpol')\n                mode = 'hpol'\n        else:\n            print('No mode given.  Defaulting to hpol')\n            mode = 'hpol'\n\n        #palmetto is a reflection?\n        #Need to label which ones work for vpol and hpol\n        #use_sources = ['Solar Plant','Quarry Substation','Tonopah KTPH','Dyer Cell Tower','Beatty Airport Vortac','Palmetto Cell Tower','Cedar Peak','Goldfield Hill Tower','Goldield Town Tower','Goldfield KGFN-FM','Silver Peak Town Antenna','Silver Peak Lithium Mine','Past SP Substation','Silver Peak Substation']\n        \n        # 'Solar Plant Substation'\n        # Some crosspol. definitely mostly hpol\n\n        # 'Dyer or Tonopah'\n        # Very crosspol, good for both calibrations\n\n        # 'Beatty Airport VORTAC'\n        # Should work for vpol\n\n        # 'Silver Peak or Distant Substation'\n        # Basically no vpol\n\n        # 'Palmetto Tower'\n        # Cross pol, not the most impulsive\n\n        # 'Goldfield Radio'\n        # Impulsive cross pol, better for hpol though\n        valley_source_run = 1650\n\n        #included_airplanes = [ '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166']\n        if False:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0\n            airplane_weight = 1.0\n            # Southern Calibration\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                use_sources = ['Solar Plant']#,'Beatty Substation','Palmetto Cell Tower', 'Cedar Peak'] #Southern Calibration\n                included_pulsers = ['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes =      [ '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166']\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['East Dyer Substation','Goldfield KGFN-FM']\n                included_pulsers = ['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n        elif False:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0\n            airplane_weight = 1.0\n            # Southern Calibration\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                use_sources = ['East Dyer Substation','Goldfield KGFN-FM','Silver Peak Substation']#,'Beatty Substation','Palmetto Cell Tower', 'Cedar Peak'] #Southern Calibration\n                included_pulsers = ['run1507','run1509'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['East Dyer Substation','Goldfield KGFN-FM']\n                included_pulsers = ['run1507','run1509'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n        elif False:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0\n            airplane_weight = 1.0\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                # Northern Calibration\n                #use_sources = ['Tonopah KTPH','Solar Plant','Silver Peak Substation']#,'Beatty Substation','Palmetto Cell Tower', 'Cedar Peak'] #Southern Calibration\n                use_sources = ['Tonopah KTPH','Solar Plant']\n                included_pulsers = ['run1507','run1509']#['run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['Tonopah KTPH','Solar Plant']\n                included_pulsers = ['run1507','run1509']#['run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n        \n        elif False:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 0.0\n            valley_weight = 0.0\n            airplane_weight = 0.0\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                use_sources = []#['Tonopah Airport Antenna','Tonopah AFS GATR Site','Dome Thing','Silver Peak Town Antenna']#['East Dyer Substation','Goldfield KGFN-FM','Tonopah KTPH','Solar Plant','Silver Peak Substation']#['Tonopah KTPH','Solar Plant','Silver Peak Substation']#'East Dyer Substation',\n                included_pulsers = ['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1509']#['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['Tonopah Airport Antenna','Tonopah AFS GATR Site','Dome Thing']#'East Dyer Substation',\n                included_pulsers = ['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n        elif False:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0\n            airplane_weight = 1.0\n            unknown_source_dir_valley = True #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            unique_cut_subset = ['Solar Plant','Tonopah KTPH','West Dyer Substation','East Dyer Substation','Beatty Mountain Cell Tower','Palmetto Cell Tower','Goldfield Hill Tower','Silver Peak Substation'] #these are all uniquely identified clusters.  Their names are not certain sources\n            if mode == 'hpol':\n                use_sources = ['Solar Plant','Tonopah KTPH','West Dyer Substation','East Dyer Substation','Beatty Mountain Cell Tower','Palmetto Cell Tower','Goldfield Hill Tower','Silver Peak Substation']#['Solar Plant','Tonopah KTPH','Palmetto Cell Tower','Goldfield Hill Tower','Silver Peak Substation']#['East Dyer Substation','Goldfield KGFN-FM','Tonopah KTPH','Solar Plant','Silver Peak Substation']#['Tonopah KTPH','Solar Plant','Silver Peak Substation']#'East Dyer Substation',\n                included_pulsers = ['run1507','run1509','run1511']#['run1509']#['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['East Dyer Substation']#'East Dyer Substation',\n                included_pulsers = ['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n        elif False:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0\n            airplane_weight = 1.0\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            unique_cut_subset = ['Solar Plant','Tonopah KTPH','West Dyer Substation','East Dyer Substation','Beatty Mountain Cell Tower','Palmetto Cell Tower','Goldfield Hill Tower','Silver Peak Substation'] #these are all uniquely identified clusters.  Their names are not certain sources\n            if mode == 'hpol':\n                use_sources = ['Solar Plant']#['Solar Plant            ','Tonopah KTPH','Palmetto Cell Tower','Goldfield Hill Tower','Silver Peak Substation']#['East Dyer Substation','Goldfield KGFN-FM','Tonopah KTPH','Solar Plant','Silver Peak Substation']#['Tonopah KTPH','Solar Plant','Silver Peak Substation']#'East Dyer Substation',\n                included_pulsers = ['run1507','run1509','run1511']#['run1509']#['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['Solar Plant']#'East Dyer Substation',\n                included_pulsers = ['run1507','run1509','run1511']#['run1507','run1509','run1511']#['run1507','run1509','run1511'] #Only included if include_pulsers == True\n                included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n                included_cw_sources = []\n        elif False:\n            unknown_source_dir_valley = True #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                use_sources = ['Miller Substation','Palmetto Cell Tower','Tonopah AFS GATR Site']#['South Dyer Town','Quarry Substation']#['South Dyer Town','Quarry Substation']#,'Palmetto Cell Tower','Beatty Airport Vortac'#['Dyer Cell Tower', 'Test Site A']#,'Miller Substation','Dyer House Antenna A','Cedar Peak']#['Miller Substation']#['Dyer Cell Tower','Miller Substation','Dyer House Antenna A','Cedar Peak']\n                included_pulsers = []\n                included_airplanes = ['1728-62026']#['1774-178']#['1728-62026','1773-14413','1773-63659','1774-178']##\n                included_cw_sources = ['khsv']\n            elif mode == 'vpol':\n                use_sources = ['Tonopah Airport Antenna','Tonopah AFS GATR Site','Dome Thing','Silver Peak Town Antenna']#'East Dyer Substation',\n                included_pulsers = []#\n                included_airplanes = ['1728-62026','1773-14413','1773-63659','1774-178']\n                included_cw_sources = []\n            \n            pulser_weight  = len(included_pulsers) #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = len(use_sources)\n            airplane_weight = 0#5*len(included_airplanes)\n\n        elif False:\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                use_sources = ['Tokop','Palmetto Cell Tower','Dyer Cell Tower','Tonopah AFS GATR Site']#['South Dyer Town','Quarry Substation']#,'Palmetto Cell Tower','Beatty Airport Vortac'#['Dyer Cell Tower', 'Test Site A']#,'Miller Substation','Dyer House Antenna A','Cedar Peak']#['Miller Substation']#['Dyer Cell Tower','Miller Substation','Dyer House Antenna A','Cedar Peak']\n                included_pulsers = []\n                included_airplanes = ['1774-178']#['1774-178']#['1728-62026','1773-14413','1773-63659','1774-178']##\n                included_cw_sources = []\n            elif mode == 'vpol':\n                use_sources = ['Tonopah Airport Antenna','Tonopah AFS GATR Site','Dome Thing','Silver Peak Town Antenna']#'East Dyer Substation',\n                included_pulsers = []#\n                included_airplanes = ['1728-62026','1773-14413','1773-63659','1774-178']\n                included_cw_sources = []\n            \n            pulser_weight  = len(included_pulsers) #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = len(use_sources)\n            airplane_weight = 5*len(included_airplanes)\n\n        elif False:\n            unknown_source_dir_valley = True #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'gaus'#'strip'#'cor'#options are 'cor' or 'strip'.  If 'cor' ch,osen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                #use_sources = ['Booker Antenna','Miller Substation','Tonopah KTPH','KNKN223','Beatty Airport Vortac']#['Tonopah AFS GATR Site','Beatty Airport Vortac']#['Miller Substation', 'Tonopah AFS GATR Site','Palmetto Cell Tower','Beatty Airport Vortac']#,'Tonopah AFS GATR Site','Palmetto Cell Tower','Beatty Airport Vortac']#['South Dyer Town','Quarry Substation']#['South Dyer Town','Quarry Substation']#,'Palmetto Cell Tower','Beatty Airport Vortac'#['Dyer Cell Tower', 'Test Site A']#,'Miller Substation','Dyer House Antenna A','Cedar Peak']#['Miller Substation']#['Dyer Cell Tower','Miller Substation','Dyer House Antenna A','Cedar Peak']\n                use_sources = [ 'Northern Cell Tower',\\\n                                'Tonopah KTPH',\\\n                                'Tonopah AFS GATR Site',\\\n                                'Miller Substation',\\\n                                'Tonopah Vortac',\\\n                                'Dyer Cell Tower',\\\n                                'East Dyer Substation',\\\n                                'Beatty Airport Antenna',\\\n                                'Palmetto Cell Tower',\\\n                                'Cedar Peak',\\\n                                'Silver Peak Substation']\n                included_pulsers = []#['run1509']#,'run1507','run1511']#\n                included_airplanes = []#['1728-62026']#['1774-178']#['1728-62026','1773-14413','1773-63659','1774-178']##\n                included_cw_sources = []#['khsv']\n            elif mode == 'vpol':\n                #Don't use palmetto for vpol\n                use_sources = ['Tonopah AFS GATR Site','Beatty Airport Vortac','KNKN223']#['Miller Substation']#['Miller Substation','Tonopah AFS GATR Site','Beatty Airport Vortac']#['Tonopah Airport Antenna','Tonopah AFS GATR Site','Dome Thing','Silver Peak Town Antenna']#'East Dyer Substation',\n                included_pulsers = []#['run1509']#,'run1507','run1511']#\n                included_airplanes = []\n                included_cw_sources = ['khsv']\n            \n            pulser_weight  = 1.0#len(included_pulsers) #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0#len(use_sources)\n            airplane_weight = 1.0#5*len(included_airplanes)\n\n        elif True:\n            unknown_source_dir_valley = True #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#'cor'#options are 'cor' or 'strip'.  If 'cor' ch,osen then the most impulsive event will be chosen and use to generate maps.\n            if mode == 'hpol':\n                #use_sources = ['Booker Antenna','Miller Substation','Tonopah KTPH','KNKN223','Beatty Airport Vortac']#['Tonopah AFS GATR Site','Beatty Airport Vortac']#['Miller Substation', 'Tonopah AFS GATR Site','Palmetto Cell Tower','Beatty Airport Vortac']#,'Tonopah AFS GATR Site','Palmetto Cell Tower','Beatty Airport Vortac']#['South Dyer Town','Quarry Substation']#['South Dyer Town','Quarry Substation']#,'Palmetto Cell Tower','Beatty Airport Vortac'#['Dyer Cell Tower', 'Test Site A']#,'Miller Substation','Dyer House Antenna A','Cedar Peak']#['Miller Substation']#['Dyer Cell Tower','Miller Substation','Dyer House Antenna A','Cedar Peak']\n                use_sources = [ 'A', 'B', 'C', 'D', 'F'] #'E' looks like it has particularly bad zenith, might be close and obstructed.\n                included_pulsers = []#['run1509']#,'run1507','run1511']#\n                included_airplanes = []#['1728-62026']#['1774-178']#['1728-62026','1773-14413','1773-63659','1774-178']##\n                included_cw_sources = []#['khsv']\n            elif mode == 'vpol':\n                #Don't use palmetto for vpol\n                use_sources = [ 'A', 'B',  'D']#['Miller Substation']#['Miller Substation','Tonopah AFS GATR Site','Beatty Airport Vortac']#['Tonopah Airport Antenna','Tonopah AFS GATR Site','Dome Thing','Silver Peak Town Antenna']#'East Dyer Substation',\n                included_pulsers = []#['run1509']#,'run1507','run1511']#\n                included_airplanes = []\n                included_cw_sources = []#['khsv']\n            \n            pulser_weight  = 1.0#len(included_pulsers) #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0#len(use_sources)\n            airplane_weight = 1.0#5*len(included_airplanes)\n            \n        else:\n            pulser_weight = 1.0 #The ratio of these three components of the chi^2 can be adjusted here.  These numbers directly multiply by their respective components before they are added to the chi^2 value.\n            cw_weight = 1.0\n            valley_weight = 1.0\n            airplane_weight = 1.0\n            unknown_source_dir_valley = False #If true then the chi^2 will not assume known arrival directions, but will instead just attempt to get overlap ANYWHERE for all selected populations.\n            unknown_mode = 'strip'#options are 'cor' or 'strip'.  If 'cor' chosen then the most impulsive event will be chosen and use to generate maps.\n            use_sources = [] #iterating through potential sources until something makes sense\n            included_pulsers = ['run1507','run1509','run1511']#,'run1511' #Only included if include_pulsers == True\n            included_airplanes = []# '1728-62026', '1773-14413', '1773-63659', '1774-178', '1774-88800', '1783-28830', '1784-7166'\n            included_cw_sources = ['khsv']\n\n        if unknown_source_dir_valley == True:\n            print('USING UNKNOWN SOURCE DIR FOR VALLEY SOURCES IN MODE: %s'%unknown_mode)\n        #only_plot = ['Booker Antenna','Miller Substation','Tonopah Airport Antenna','Tonopah KTPH','KNKN223','Tonopah AFS GATR Site','Dome Thing','Silver Peak Town Antenna','Dyer House Antenna A','Beatty Airport Vortac']\n        only_plot = use_sources\n        # only_plot.append('Concrete Substation')\n        # only_plot.append('Dyer Cell Tower')\n        # only_plot.append('Miller Substation')\n        # only_plot.append('Solar Plant')\n        # only_plot.append('Booker Antenna')\n        # only_plot.append('Silver Peak Town Antenna')\n        # only_plot.append('Silver Peak Lithium Mine')\n        # only_plot.append('Past SP Substation'      )\n        # only_plot.append('Palmetto Cell Tower')\n        # only_plot.append('Cedar Peak')\n        # only_plot.append('Beatty Airport Vortac')\n        # only_plot   = [ 'Tonopah AFS GATR Site',\\\n        #                 'Tonopah Vortac']\n\n        # only_plot   = [ 'Tonopah AFS GATR Site',\\\n        #                 'Tonopah Vortac',\\\n        #                 'Tonopah Airport Antenna',\\\n        #                 'Dyer Cell Tower',\\\n        #                 'West Dyer Substation',\\\n        #                 'East Dyer Substation',\\\n        #                 'Oasis',\\\n        #                 'Beatty Substation',\\\n        #                 'Palmetto Cell Tower',\\\n        #                 'Cedar Peak',\\\n        #                 'Dome Thing',\\\n        #                 'Goldfield Hill Tower',\\\n        #                 'Silver Peak Substation',\\\n        #                 'Silver Peak Town Antenna',\\\n        #                 'Silver Peak Lithium Mine',\\\n        #                 'Past SP Substation']\n\n        # only_plot   = [ 'Solar Plant',\\\n        #                 'Tonopah KTPH',\\\n        #                 'Dyer Cell Tower',\\\n        #                 'West Dyer Substation',\\\n        #                 'East Dyer Substation',\\\n        #                 'Beatty Airport Vortac',\\\n        #                 'Beatty Substation',\\\n        #                 'Palmetto Cell Tower',\\\n        #                 'Black Mountain',\\\n        #                 'Cedar Peak',\\\n        #                 'Goldfield Hill Tower',\\\n        #                 'Goldield Town Tower',\\\n        #                 'Goldfield KGFN-FM',\\\n        #                 'Silver Peak Town Antenna',\\\n        #                 'Silver Peak Lithium Mine',\\\n        #                 'Past SP Substation',\\\n        #                 'Silver Peak Substation']\n        #only_plot = use_sources\n        \n        #only_plot.append('Beatty Mountain Cell Tower')\n        # only_plot.append('Goldfield Hill Tower')\n        # only_plot.append('Goldield Town Tower')\n        # only_plot.append('Goldfield KGFN-FM')\n        # only_plot.append('Beatty Airport Vortac')\n        # only_plot.append('Beatty Airport Antenna')\n        # only_plot.append('Beatty Substation')\n\n        # Azimuths\n        # Source Directions based on ENU, sorted North to South are:\n        # Dyer House Antenna A : 49.777\n        # Northern Cell Tower : 49.393\n        # KNKN223 : 49.390\n        # Quarry Substation : 46.095\n        # Solar Plant : 43.441\n        # Miller Substation : 41.522\n        # Tonopah AFS GATR Site : 34.267\n        # Nye County Sherriff : 32.643\n        # Booker Antenna : 31.535\n        # Tonopah KTPH : 30.265\n        # Dyer Cell Tower : 29.118\n        # Tonopah Airport Antenna : 27.992\n        # Tonopah Vortac : 25.165\n        # Silver Peak Lithium Mine : 19.259\n        # Silver Peak Substation : 19.112\n        # Silver Peak Town Antenna : 18.844\n        # Past SP Substation : 18.444\n        # Concrete Substation : 16.432\n        # Test Site A : 14.821\n        # Goldfield Hill Tower : 10.018\n        # Goldield Town Tower : 8.967\n        # Goldfield KGFN-FM : 8.803\n        # Dome Thing : 7.449\n        # Cedar Peak : 4.992\n        # Jack Rabbit Knob : 4.582\n        # West Dyer Substation : 3.050\n        # South Dyer Town : -2.629\n        # Black Mountain : -13.073\n        # Palmetto Cell Tower : -13.323\n        # East Dyer Substation : -17.366\n        # Tokop : -20.082\n        # Oasis : -21.666\n        # Beatty Substation : -29.850\n        # Beatty Mountain Cell Tower : -30.127\n        # Beatty Airport Antenna : -31.380\n        # Beatty Airport Vortac : -33.040\n\n\n\n\n        plot_animated_airplane = False #Otherwise plots first event from each plane.\n        plot_expected_airplane_direction = True\n        plot_airplane_tracks = True\n        plot_time_delay_calculations = False\n        plot_time_delays_on_maps = True\n        plot_expected_direction = True\n        plot_cw_overlap = True\n        limit_events = 10 #Number of events use for time delay calculation\n        #only_plot = ['East Dyer Substation','West Dyer Substation','Northern Cell Tower','Solar Plant','Quarry Substation','Tonopah KTPH','Dyer Cell Tower','Tonopah Vortac','Beatty Airport Vortac','Palmetto Cell Tower','Cedar Peak','Goldfield Hill Tower','Goldield Town Tower','Goldfield KGFN-FM','Silver Peak Town Antenna','Silver Peak Lithium Mine','Past SP Substation','Silver Peak Substation']#['Solar Plant','Tonopah KTPH','Beatty Airport Vortac','Palmetto Cell Tower','Goldfield Hill Tower','Silver Peak Substation']\n        # impulsivity_dset_key = 'LPf_100.0-LPo_8-HPf_None-HPo_None-Phase_1-Hilb_0-corlen_65536-align_0-shortensignals-0-shortenthresh-0.70-shortendelay-10.00-shortenlength-90.00-sinesubtract_1'\n        # time_delays_dset_key = 'LPf_100.0-LPo_8-HPf_None-HPo_None-Phase_1-Hilb_0-corlen_65536-align_0-shortensignals-0-shortenthresh-0.70-shortendelay-10.00-shortenlength-90.00-sinesubtract_1'\n        # map_direction_dset_key = 'LPf_100.0-LPo_8-HPf_None-HPo_None-Phase_1-Hilb_0-upsample_32768-maxmethod_0-sinesubtract_1-deploy_calibration_22-scope_belowhorizon'#'LPf_70.0-LPo_4-HPf_None-HPo_None-Phase_1-Hilb_1-upsample_32768-maxmethod_0'#'LPf_100.0-LPo_8-HPf_None-HPo_None-Phase_1-Hilb_1-upsample_32768-maxmethod_0-sinesubtract_1'\n        time_delays_dset_key = 'LPf_85.0-LPo_6-HPf_25.0-HPo_8-Phase_1-Hilb_0-corlen_131072-align_0-shortensignals-0-shortenthresh-0.70-shortendelay-10.00-shortenlength-90.00-sinesubtract_1'\n        impulsivity_dset_key = time_delays_dset_key\n        map_direction_dset_key = 'LPf_85.0-LPo_6-HPf_25.0-HPo_8-Phase_1-Hilb_0-upsample_16384-maxmethod_0-sinesubtract_1-deploy_calibration_30-n_phi_1440-min_phi_neg180-max_phi_180-n_theta_720-min_theta_0-max_theta_180-scope_allsky'\n\n\n        plot_residuals = False\n        plot_histograms = False\n        iterate_sub_baselines = 6 #The lower this is the higher the time it will take to plot.  Does combinatoric subsets of baselines with this length. \n        #plot_time_delays_on_maps = False\n\n        final_corr_length = 2**17\n        cor_upsample = final_corr_length\n\n        crit_freq_low_pass_MHz = 85#None#[80,70,70,70,70,70,60,70]#90#\n        low_pass_filter_order = 6#None#[0,8,8,8,10,8,3,8]#8#\n\n        crit_freq_high_pass_MHz = 25#70#None#60\n        high_pass_filter_order = 8#6#None#8\n\n        sine_subtract = True\n        sine_subtract_min_freq_GHz = 0.03\n        sine_subtract_max_freq_GHz = 0.13\n        sine_subtract_percent = 0.03\n\n        waveform_index_range = (None,None)\n\n        apply_phase_response = True\n        hilbert = False\n\n\n        '''\n        #The parameters as set before trying to go back.  These start from deploy_index=19 and try to get a 4 antenna match.\n        include_pulsers = True \n        include_baseline_measurements = False\n        baseline_measurement_uncertainty_m = 3 #Assuming a 3m spread in our data.  This is very approximate.\n        time_delay_measurement_uncertainty_ns = 25 #ns, The time window used to as error in chi^2 for time delay.  If you are assuming that the time delays are 100% accurate then this is usually sub ns.  But if you think it is slipping cycles you could give this a larger value. \n        include_sanity = False #Slow\n        plot_predicted_time_shifts = False\n        random_offset_amount = 0.25 #m (every antenna will be stepped randomly by this amount.  Set to 0 if you don't want this. ), Note that this is applied to \n        included_antennas_lumped = [0,1,2,3] #If an antenna is not in this list then it will not be included in the chi^2 (regardless of if it is fixed or not)  Lumped here imlies that antenna 0 in this list means BOTH channels 0 and 1 (H and V of crossed dipole antenna 0).\n        included_antennas_channels = numpy.concatenate([[2*i,2*i+1] for i in included_antennas_lumped])\n        include_baselines = [0,1,2,3,4,5] #Basically sets the starting condition of which baselines to include, then the lumped channels and antennas will cut out further from that.  The above options of excluding antennas will override this to exclude baselines, but if both antennas are included but the baseline is not then it will not be included.  Overwritten when antennas removed.\n        plot_overlap = True #Will plot the overlap map for time delays from each source.\n        overlap_window_ns = 50 #ns The time window used to define sufficient overlap. \n        overlap_goal = overlap_window_ns*len(included_antennas_channels)*len(use_sources) #This shouldn't be varied, vary the error if anything.  This is the portion of chi^2 coming from overlapping valley source time delays.  The measured map max will be subtracted from this in a chi^2 calculation.  \n        overlap_error = overlap_goal/50 #The error portion of chi^2 coming from overlapping valley source time delays will be devided by this number.\n        limit_array_plane_azimuth_range = False #Should be seen as a temporary test.  Doesn't use any errors and isn't in standard chi^2 format.\n        allowed_array_plane_azimuth_range = 20 #plus or minus this from East is not impacted by weighting. \n\n        #Limits \n        initial_step_x = 0.25#75 #m\n        initial_step_y = 0.75#75 #m\n        initial_step_z = 0.75#5 #m\n        initial_step_cable_delay = 1.0 #ns\n        cable_delay_guess_range = 10 #ns\n        antenna_position_guess_range_x = 1#2#4 #Limit to how far from input phase locations to limit the parameter space to\n        antenna_position_guess_range_y = 1#2#7 #Limit to how far from input phase locations to limit the parameter space to\n        antenna_position_guess_range_z = 1#3 #Limit to how far from input phase locations to limit the parameter space to\n\n        #Manually shifting input of antenna 0 around so that I can find a fit that has all of its baselines visible for valley sources. \n        manual_offset_ant0_x = 14#6\n        manual_offset_ant0_y = -2.7#15\n        manual_offset_ant0_z = -17#-4\n\n        '''\n        #Parameters trying to achieve the 3 antenna match starting from deploy_index = 13.\n        include_pulsers = True \n        include_baseline_measurements = False\n        baseline_measurement_uncertainty_m = 3 #Assuming a 3m spread in our data.  This is very approximate.\n        time_delay_measurement_uncertainty_ns = 1 #ns, The time window used to as error in chi^2 for time delay.  If you are assuming that the time delays are 100% accurate then this is usually sub ns.  But if you think it is slipping cycles you could give this a larger value. \n        include_sanity = False #Slow\n        plot_predicted_time_shifts = False\n        random_offset_amount = 1#0.25 #m (every antenna will be stepped randomly by this amount.  Set to 0 if you don't want this. ), Note that this is applied to \n        included_antennas_lumped = [0,1,2,3]#[0,1,2,3] #If an antenna is not in this list then it will not be included in the chi^2 (regardless of if it is fixed or not)  Lumped here imlies that antenna 0 in this list means BOTH channels 0 and 1 (H and V of crossed dipole antenna 0).\n        included_antennas_channels = numpy.concatenate([[2*i,2*i+1] for i in included_antennas_lumped])\n        include_baselines = [0,1,2,3,4,5]#[1,3,5] #Basically sets the starting condition of which baselines to include, then the lumped channels and antennas will cut out further from that.  The above options of excluding antennas will override this to exclude baselines, but if both antennas are included but the baseline is not then it will not be included.  Overwritten when antennas removed.\n        plot_overlap = False #Will plot the overlap map for time delays from each source.\n        overlap_window_ns = 10 #ns The time window used to define sufficient overlap. \n        overlap_value_mode = 'gaus' #'distance'\n        limit_array_plane_azimuth_range = False #Should be seen as a temporary test.  Doesn't use any errors and isn't in standard chi^2 format.\n        allowed_array_plane_azimuth_range = 20 #plus or minus this from East is not impacted by weighting. \n\n        #Limits \n        initial_step_x = 0.25#2.0 #m\n        initial_step_y = 0.25#2.0 #m\n        initial_step_z = 0.25#0.75 #m\n        initial_step_cable_delay = 0.2 #ns\n        cable_delay_guess_range = 10 #ns\n        antenna_position_guess_range_x = 1.0#20#10#3#5#4#2#4 #Limit to how far from input phase locations to limit the parameter space to\n        antenna_position_guess_range_y = 3.0#20#10#3#5#4#2#7 #Limit to how far from input phase locations to limit the parameter space to\n        antenna_position_guess_range_z = 1.0#20#5#4#3#2#3 #Limit to how far from input phase locations to limit the parameter space to\n\n        #Manually shifting input of antenna 0 around so that I can find a fit that has all of its baselines visible for valley sources. \n        manual_offset_ant0_x = 0#0#0#14\n        manual_offset_ant0_y = 0#0#0#-2.7\n        manual_offset_ant0_z = 0#0#0#-17\n\n        manual_offset_ant1_x = 0#0#-1#0#-3.23884999 #-1#0    + manual_offset_ant0_x\n        manual_offset_ant1_y = 0#0#5#0#-0.54016485 #-1#-2   + manual_offset_ant0_y\n        manual_offset_ant1_z = 0#-5#0#-5.  #-1#0    + manual_offset_ant0_z\n\n        manual_offset_ant2_x = 0#3#0#0#0#5. #8#0    + manual_offset_ant0_x\n        manual_offset_ant2_y = 0#10#0#-5#0#-6.59619457 #-5#-4   + manual_offset_ant0_y\n        manual_offset_ant2_z = 0#0#0#-5#12#0#9. #5#0    + manual_offset_ant0_z\n\n        manual_offset_ant3_x = 0#0#-3#0#-3#0    + manual_offset_ant0_x\n        manual_offset_ant3_y = 0#0#0#0#0#0    + manual_offset_ant0_y\n        manual_offset_ant3_z = 0#-5#0#3#-6   + manual_offset_ant0_z\n\n\n        fix_ant0_x = True\n        fix_ant0_y = True\n        fix_ant0_z = True\n        fix_ant1_x = False\n        fix_ant1_y = False\n        fix_ant1_z = False\n        fix_ant2_x = False\n        fix_ant2_y = False\n        fix_ant2_z = False\n        fix_ant3_x = False\n        fix_ant3_y = False\n        fix_ant3_z = False\n        fix_cable_delay0 = True\n        fix_cable_delay1 = False\n        fix_cable_delay2 = False\n        fix_cable_delay3 = False\n\n        #Force antennas not to be included to be fixed.  \n        if not(0 in included_antennas_lumped):\n            fix_ant0_x = True\n            fix_ant0_y = True\n            fix_ant0_z = True\n            fix_cable_delay0 = True\n\n        if not(1 in included_antennas_lumped):\n            fix_ant1_x = True\n            fix_ant1_y = True\n            fix_ant1_z = True\n            fix_cable_delay1 = True\n        if not(2 in included_antennas_lumped):\n            fix_ant2_x = True\n            fix_ant2_y = True\n            fix_ant2_z = True\n            fix_cable_delay2 = True\n        if not(3 in included_antennas_lumped):\n            fix_ant3_x = True\n            fix_ant3_y = True\n            fix_ant3_z = True\n            fix_cable_delay3 = True\n\n        #This math is to set the pairs to include in the calculation.  Typically it will be all of them, but if the option is enabled to remove some\n        #from the calculation then this will allow for that to be done.\n        pairs = numpy.array(list(itertools.combinations((0,1,2,3), 2)))\n        pairs_cut = []\n        for pair_index, pair in enumerate(numpy.array(list(itertools.combinations((0,1,2,3), 2)))):\n            pairs_cut.append(numpy.logical_and(numpy.all(numpy.isin(numpy.array(pair),included_antennas_lumped)), pair_index in include_baselines)) #include_baselines Overwritten when antennas removed.\n        include_baselines = numpy.where(pairs_cut)[0] #Effectively the same as the pairs_cut but index based for baselines.\n        print('Including baseline pairs:')\n        print(pairs[pairs_cut])\n        if overlap_value_mode == 'distance':\n            overlap_goal = overlap_window_ns*len(include_baselines)#overlap_window_ns*len(included_antennas_channels)*len(use_sources) #This shouldn't be varied, vary the error if anything.  This is the portion of chi^2 coming from overlapping valley source time delays.  The measured map max will be subtracted from this in a chi^2 calculation.  \n            overlap_error = overlap_goal/50 #The error portion of chi^2 coming from overlapping valley source time delays will be devided by this number.\n        elif overlap_value_mode == 'gaus':\n            overlap_goal = len(include_baselines) #the maps are summed rather than averaged.  The gaussian is normalized such that it's peak value is 1.\n            overlap_error = overlap_window_ns / 2.355 #Standard deviation as utilized in the overlap map generator.\n        \n\n\n        #I think adding an absolute time offset for each antenna and letting that vary could be interesting.  It could be used to adjust the cable delays.\n        cable_delays = info.loadCableDelays(return_raw=True)[mode]\n        print('Potential RFI Source Locations.')\n        sources_ENU, data_slicer_cut_dict = info.loadValleySourcesENU()\n\n\n        print('Source Directions based on ENU, sorted North to South are:')\n\n        keys = list(sources_ENU.keys())\n        azimuths = []\n\n        for source_key in keys:\n            azimuths.append(numpy.rad2deg(numpy.arctan2(sources_ENU[source_key][1],sources_ENU[source_key][0])))\n\n        sort_cut = numpy.argsort(azimuths)[::-1]\n        for index in sort_cut:\n            print('%s : %0.3f'%(keys[index], azimuths[index]))\n\n        pulser_locations_ENU = info.loadPulserLocationsENU()\n        known_pulser_ids = info.loadPulserEventids(remove_ignored=True)\n        if include_pulsers:\n            pulser_time_delay_dict = {}\n            pulser_time_delay_error_dict = {}\n            if mode == 'hpol':\n                if hilbert == True:\n                    pulser_time_delay_dict['run1507'] = site1_measured_time_delays_hilbert_hpol\n                    pulser_time_delay_error_dict['run1507'] = site1_measured_time_delays_hilbert_errors_hpol\n\n                    pulser_time_delay_dict['run1509'] = site2_measured_time_delays_hilbert_hpol\n                    pulser_time_delay_error_dict['run1509'] = site2_measured_time_delays_hilbert_errors_hpol\n\n                    pulser_time_delay_dict['run1511'] = site3_measured_time_delays_hilbert_hpol\n                    pulser_time_delay_error_dict['run1511'] = site3_measured_time_delays_hilbert_errors_hpol\n                else:\n                    pulser_time_delay_dict['run1507'] = site1_measured_time_delays_hpol\n                    pulser_time_delay_error_dict['run1507'] = site1_measured_time_delays_errors_hpol\n\n                    pulser_time_delay_dict['run1509'] = site2_measured_time_delays_hpol\n                    pulser_time_delay_error_dict['run1509'] = site2_measured_time_delays_errors_hpol\n\n                    pulser_time_delay_dict['run1511'] = site3_measured_time_delays_hpol\n                    pulser_time_delay_error_dict['run1511'] = site3_measured_time_delays_errors_hpol\n            else:\n                if hilbert == True:\n                    pulser_time_delay_dict['run1507'] = site1_measured_time_delays_hilbert_vpol\n                    pulser_time_delay_error_dict['run1507'] = site1_measured_time_delays_hilbert_errors_vpol\n\n                    pulser_time_delay_dict['run1509'] = site2_measured_time_delays_hilbert_vpol\n                    pulser_time_delay_error_dict['run1509'] = site2_measured_time_delays_hilbert_errors_vpol\n\n                    pulser_time_delay_dict['run1511'] = site3_measured_time_delays_hilbert_vpol\n                    pulser_time_delay_error_dict['run1511'] = site3_measured_time_delays_hilbert_errors_vpol\n                else:\n                    pulser_time_delay_dict['run1507'] = site1_measured_time_delays_vpol\n                    pulser_time_delay_error_dict['run1507'] = site1_measured_time_delays_errors_vpol\n\n                    pulser_time_delay_dict['run1509'] = site2_measured_time_delays_vpol\n                    pulser_time_delay_error_dict['run1509'] = site2_measured_time_delays_errors_vpol\n\n                    pulser_time_delay_dict['run1511'] = site3_measured_time_delays_vpol\n                    pulser_time_delay_error_dict['run1511'] = site3_measured_time_delays_errors_vpol\n        \n\n            if plot_predicted_time_shifts:\n                for run in [1507,1509,1511]:\n                    if run == 1507:\n                            _waveform_index_range = (1500,2000) #Looking at the later bit of the waveform only, 10000 will cap off.  \n                    elif run == 1509:\n                            _waveform_index_range = (2500,3000) #Looking at the later bit of the waveform only, 10000 will cap off.  \n                    elif run == 1511:\n                            _waveform_index_range = (1250,1750) #Looking at the later bit of the waveform only, 10000 will cap off.  \n                    reader = Reader(datapath,run)\n                    tdc = TimeDelayCalculator(reader, final_corr_length=final_corr_length, crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order,waveform_index_range=_waveform_index_range,plot_filters=False,apply_phase_response=apply_phase_response)\n                    _time_delays = numpy.append(numpy.array(pulser_time_delay_dict['run%i'%run])[:,1],numpy.array(pulser_time_delay_dict['run%i'%run])[:,1]) #Just duplicating, I am only plotting the ones for this polarization anyways.\n                    if mode == 'hpol':\n                        _eventid = numpy.random.choice(known_pulser_ids['run%i'%run]['hpol'])\n                        _fig, _ax = tdc.plotEvent(_eventid, channels=[0,2,4,6], apply_filter=True, hilbert=hilbert, sine_subtract=True, apply_tukey=None, additional_title_text='Sample Event shifted by input time delays', time_delays=_time_delays)\n                    else:\n                        _eventid = numpy.random.choice(known_pulser_ids['run%i'%run]['vpol'])\n                        _fig, _ax = tdc.plotEvent(_eventid, channels=[1,3,5,7], apply_filter=True, hilbert=hilbert, sine_subtract=True, apply_tukey=None, additional_title_text='Sample Event shifted by input time delays', time_delays=_time_delays)\n\n        #Note the above ROI assumes you have already cut out events that are below a certain correlation with a template.\n        # ds.addROI('Simple Template V > 0.7',{'cr_template_search_v':[0.7,1.0]})# Adding 2 ROI in different rows and appending as below allows for \"OR\" instead of \"AND\"\n        # ds.addROI('Simple Template H > 0.7',{'cr_template_search_h':[0.7,1.0]})\n        # #Done for OR condition\n        # _eventids = numpy.sort(numpy.unique(numpy.append(ds.getCutsFromROI('Simple Template H > 0.7',load=False,save=False),ds.getCutsFromROI('Simple Template V > 0.7',load=False,save=False))))\n        # roi_eventids = numpy.intersect1d(ds.getCutsFromROI(roi_key),_eventids)\n        antennas_physical, antennas_phase_hpol, antennas_phase_vpol = info.loadAntennaLocationsENU()\n\n        if True:\n            if mode == 'hpol':\n                antennas_phase_start = antennas_phase_hpol\n            else:\n                antennas_phase_start = antennas_phase_vpol\n        else:\n            print('WARNING, USING PHYSICAL LOCATIONS TO START')\n            antennas_phase_start = antennas_physical            \n\n        colors = plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\n\n        #DETERMINE THE TIME DELAYS TO BE USED IN THE ACTUAL CALCULATION\n\n        #### VALLEY RFI PREPARATIONS ####\n\n        print('Calculating time delays from info.py')\n        reader = Reader(datapath,valley_source_run)\n        tdc = TimeDelayCalculator(reader, final_corr_length=final_corr_length, crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order,waveform_index_range=waveform_index_range,plot_filters=False,apply_phase_response=apply_phase_response)\n        if sine_subtract:\n            tdc.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n        \n\n        ds = dataSlicerSingleRun(reader, impulsivity_dset_key, time_delays_dset_key, map_direction_dset_key,\\\n                    curve_choice=0, trigger_types=[2],included_antennas=included_antennas_channels,include_test_roi=False,\\\n                    cr_template_n_bins_h=200,cr_template_n_bins_v=200,\\\n                    impulsivity_n_bins_h=200,impulsivity_n_bins_v=200,\\\n                    time_delays_n_bins_h=150,time_delays_n_bins_v=150,min_time_delays_val=-200,max_time_delays_val=200,\\\n                    std_n_bins_h=200,std_n_bins_v=200,max_std_val=9,\\\n                    p2p_n_bins_h=128,p2p_n_bins_v=128,max_p2p_val=128,\\\n                    snr_n_bins_h=200,snr_n_bins_v=200,max_snr_val=35)\n\n        if False:\n            ds.addROI('Simple Template V > 0.7',{'cr_template_search_v':[0.7,1.0]})# Adding 2 ROI in different rows and appending as below allows for \"OR\" instead of \"AND\"\n            ds.addROI('Simple Template H > 0.7',{'cr_template_search_h':[0.7,1.0]})\n            #Done for OR condition\n            _eventids = numpy.sort(numpy.unique(numpy.append(ds.getCutsFromROI('Simple Template H > 0.7',load=False,save=False),ds.getCutsFromROI('Simple Template V > 0.7',load=False,save=False))))\n        else:\n            _eventids = numpy.arange(ds.reader.N())\n        time_delay_dict = {}\n        time_delay_dict_eventids = {}\n        for source_key, cut_dict in data_slicer_cut_dict.items():\n            if plot_time_delays_on_maps == False:\n                #Only need some time delays\n                if not(source_key in use_sources):\n                    continue #Skipping calculating that one.\n            else:\n                if numpy.logical_and(not(source_key in use_sources),not(source_key in only_plot)):\n                    continue #Skipping calculating that one.\n\n            ds.addROI(source_key,cut_dict)\n            roi_eventids = numpy.intersect1d(ds.getCutsFromROI(source_key),_eventids)\n            roi_impulsivity = ds.getDataFromParam(roi_eventids,'impulsivity_h')\n            roi_impulsivity_sort = numpy.argsort(roi_impulsivity)[::-1] #Reverse sorting so high numbers are first.\n            time_delay_dict_eventids[source_key] = roi_eventids[roi_impulsivity_sort]\n            \n            if len(roi_eventids) > limit_events:\n                print('LIMITING TIME DELAY CALCULATION TO %i MOST IMPULSIVE EVENTS'%limit_events)\n                roi_eventids = numpy.sort(roi_eventids[roi_impulsivity_sort[0:limit_events]])\n        \n            print('Calculating time delays for %s'%source_key)\n            time_shifts, corrs, td_pairs = tdc.calculateMultipleTimeDelays(roi_eventids,align_method=0,hilbert=hilbert,plot=numpy.logical_and(source_key in use_sources,plot_time_delay_calculations), sine_subtract=sine_subtract)\n            if mode == 'hpol':\n                # for event_index, eventid in enumerate(roi_eventids):\n                #     print(eventid)\n                #     print(time_shifts[0:6,event_index])\n                time_delay_dict[source_key] = numpy.mean(time_shifts[0:6,:],axis=1) #perhaps I should be fitting.  Assuming only using sources with consistent time delays\n            else:\n                time_delay_dict[source_key] = numpy.mean(time_shifts[6:12,:],axis=1)\n            \n            all_tds = numpy.mean(time_shifts,axis=1)\n\n            if plot_predicted_time_shifts:\n                    _eventid = numpy.random.choice(roi_eventids)\n                    if mode == 'hpol':\n                        _fig, _ax = tdc.plotEvent(_eventid, channels=[0,2,4,6], apply_filter=True, hilbert=hilbert, sine_subtract=True, apply_tukey=None, additional_title_text='%s Sample Event shifted by input time delays'%source_key, time_delays=all_tds)\n                    else:\n                        _fig, _ax = tdc.plotEvent(_eventid, channels=[1,3,5,7], apply_filter=True, hilbert=hilbert, sine_subtract=True, apply_tukey=None, additional_title_text='%s Sample Event shifted by input time delays'%source_key, time_delays=all_tds)\n            print('time_delay_dict[%s] = '%source_key)\n            print(time_delay_dict[source_key])\n            \n        for key in list(sources_ENU.keys()):\n            if key in use_sources:\n                print('Using key %s'%key)\n                continue\n            else:\n                del sources_ENU[key]\n                del data_slicer_cut_dict[key]\n\n\n\n        #### AIRPLANES ####\n        if len(included_airplanes) > 0:\n            try_to_use_precalculated_time_delays_airplanes = True\n            try_to_use_precalculated_time_delays_airplanes_but_just_as_guess_for_real_time_delays_why_is_this_so_long = False\n\n            print('Loading known plane locations.')\n            known_planes, calibrated_trigtime, output_tracks = pt.getKnownPlaneTracks(ignore_planes=[]) # ['1728-62026','1773-14413','1773-63659','1774-88800','1783-28830','1784-7166']#'1774-88800','1728-62026'\n            origin = info.loadAntennaZeroLocation()\n            antennas_physical, antennas_phase_hpol, antennas_phase_vpol = info.loadAntennaLocationsENU()\n            if mode == 'hpol':\n                antennas_phase_start = antennas_phase_hpol\n            else:\n                antennas_phase_start = antennas_phase_vpol\n\n            plane_polys = {}\n            interpolated_plane_locations = {}\n            measured_plane_time_delays = {}\n\n            if plot_airplane_tracks == True:\n                plane_fig = plt.figure()\n                plane_fig.canvas.set_window_title('3D Plane Tracks')\n                plane_ax = plane_fig.add_subplot(111, projection='3d')\n                plane_ax.scatter(0,0,0,label='Antenna 0',c='k')\n            colors = plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\n\n            airplane_pair_cuts = {}\n            for index, key in enumerate(list(calibrated_trigtime.keys())):\n                if key not in included_airplanes:\n                    continue\n\n                pair_cut = numpy.array([pair in known_planes[key]['baselines'][mode] for pair in [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]] ]) #Checks which td_pairs are worth looping over.\n                pair_cut = numpy.logical_and(pair_cut,numpy.isin([0,1,2,3,4,5],include_baselines)) #To include the ability to disable baselines from this scripts settings.\n                if sum(pair_cut) < len(include_baselines):\n                    print('%s using less baselines than specified.'%key)\n                airplane_pair_cuts[key] = pair_cut\n\n                run = int(key.split('-')[0])\n                reader = Reader(datapath,run)\n                eventids = known_planes[key]['eventids'][:,1]\n\n                enu = numpy.array(pm.geodetic2enu(output_tracks[key]['lat'],output_tracks[key]['lon'],output_tracks[key]['alt'],origin[0],origin[1],origin[2]))\n                \n                unique_enu_indices = numpy.sort(numpy.unique(enu,axis=1,return_index=True)[1])\n                distance = numpy.sqrt(enu[0]**2 + enu[0]**2 + enu[0]**2)\n                distance_cut_indices = numpy.where(distance/1000.0 < 100)\n                unique_enu_indices = unique_enu_indices[numpy.isin(unique_enu_indices,distance_cut_indices)]\n                \n                plane_polys[key] = pt.PlanePoly(output_tracks[key]['timestamps'][unique_enu_indices],enu[:,unique_enu_indices],plot=False)\n\n                interpolated_plane_locations[key] = plane_polys[key].poly(calibrated_trigtime[key])\n                \n\n                if plot_airplane_tracks == True:\n                    #Alpha ranges from 0.5 to 1, where 0.5 is the earliest times and 1 is the later times.\n                    #alpha = 0.5 + (calibrated_trigtime[key] - min(calibrated_trigtime[key]))/(2*(max(calibrated_trigtime[key]) - min(calibrated_trigtime[key])))\n                    arrow_index = len(enu[0][unique_enu_indices])//2\n                    arrow_dir = numpy.array([(enu[0][unique_enu_indices][arrow_index+1] - enu[0][unique_enu_indices][arrow_index])/1000.0,(enu[1][unique_enu_indices][arrow_index+1] - enu[1][unique_enu_indices][arrow_index])/1000.0,(enu[2][unique_enu_indices][arrow_index+1] - enu[2][unique_enu_indices][arrow_index])/1000.0])\n                    arrow_dir = 3*arrow_dir/numpy.linalg.norm(arrow_dir)\n                    plane_ax.plot(enu[0][unique_enu_indices]/1000.0,enu[1][unique_enu_indices]/1000.0,enu[2][unique_enu_indices]/1000.0,label=key + ' : ' + known_planes[key]['known_flight'],color=colors[index])\n                    plane_ax.quiver(enu[0][unique_enu_indices][arrow_index]/1000.0,enu[1][unique_enu_indices][arrow_index]/1000.0,enu[2][unique_enu_indices][arrow_index]/1000.0, arrow_dir[0],arrow_dir[1],arrow_dir[2],color=colors[index])\n                    plane_ax.scatter(interpolated_plane_locations[key][:,0]/1000.0,interpolated_plane_locations[key][:,1]/1000.0,interpolated_plane_locations[key][:,2]/1000.0,label=key + ' : ' + known_planes[key]['known_flight'],color=colors[index])\n\n                    plt.grid()\n                    plt.show()\n\n\n                if try_to_use_precalculated_time_delays_airplanes == True and numpy.logical_and('time_delays' in list(known_planes[key].keys()),'max_corrs' in list(known_planes[key].keys())):\n                    print('Using precalculated time delays from info.py')\n                    measured_plane_time_delays[key] = known_planes[key]['time_delays'][mode].T\n\n                elif try_to_use_precalculated_time_delays_airplanes_but_just_as_guess_for_real_time_delays_why_is_this_so_long == True:\n\n                    guess_time_delays = numpy.vstack((known_planes[key]['time_delays']['hpol'].T,known_planes[key]['time_delays']['vpol'].T)).T\n\n                    print('Calculating time delays from info.py')\n                    run = int(key.split('-')[0])\n                    reader = Reader(datapath,run)\n                    tdc = TimeDelayCalculator(reader, final_corr_length=final_corr_length, crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order,waveform_index_range=waveform_index_range,plot_filters=False,apply_phase_response=apply_phase_response)\n                    if sine_subtract:\n                        tdc.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    \n                    time_shifts, corrs, td_pairs = tdc.calculateMultipleTimeDelays(eventids,align_method=10,hilbert=hilbert, align_method_10_estimates=guess_time_delays, align_method_10_window_ns=8, sine_subtract=sine_subtract)\n\n                    if mode == 'hpol':\n                        measured_plane_time_delays[key] = time_shifts[0:6,:]\n                    else:\n                        measured_plane_time_delays[key] = time_shifts[6:12,:]\n\n                else:\n                    print('Calculating time delays from info.py')\n                    run = int(key.split('-')[0])\n                    reader = Reader(datapath,run)\n                    tdc = TimeDelayCalculator(reader, final_corr_length=final_corr_length, crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order,waveform_index_range=waveform_index_range,plot_filters=False,apply_phase_response=apply_phase_response)\n                    if sine_subtract:\n                        tdc.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n                    eventids = known_planes[key]['eventids'][:,1]\n                    time_shifts, corrs, td_pairs = tdc.calculateMultipleTimeDelays(eventids,align_method=0,hilbert=hilbert, sine_subtract=sine_subtract)\n\n                    if mode == 'hpol':\n                        measured_plane_time_delays[key] = time_shifts[0:6,:]\n                    else:\n                        measured_plane_time_delays[key] = time_shifts[6:12,:]\n\n            if plot_airplane_tracks == True:\n                plane_ax.legend(loc='upper right')\n                plane_ax.set_xlabel('East (km)',linespacing=10)\n                plane_ax.set_ylabel('North (km)',linespacing=10)\n                plane_ax.set_zlabel('Up (km)',linespacing=10)\n                plane_ax.dist = 10\n\n        if len(included_cw_sources) != 0:\n            origin = info.loadAntennaZeroLocation()\n            for key in included_cw_sources:\n                cw_sources[key]['enu'] = numpy.array(pm.geodetic2enu(cw_sources['khsv']['latlonel'][0],cw_sources['khsv']['latlonel'][1],cw_sources['khsv']['latlonel'][2],origin[0],origin[1],origin[2]))\n\n\n\n        if cable_delay_guess_range is not None:\n\n            limit_cable_delay0 = (cable_delays[0] - cable_delay_guess_range , cable_delays[0] + cable_delay_guess_range)\n            limit_cable_delay1 = (cable_delays[1] - cable_delay_guess_range , cable_delays[1] + cable_delay_guess_range)\n            limit_cable_delay2 = (cable_delays[2] - cable_delay_guess_range , cable_delays[2] + cable_delay_guess_range)\n            limit_cable_delay3 = (cable_delays[3] - cable_delay_guess_range , cable_delays[3] + cable_delay_guess_range)\n        else:\n            limit_cable_delay0 = None#(cable_delays[0] , None)\n            limit_cable_delay1 = None#(cable_delays[1] , None)\n            limit_cable_delay2 = None#(cable_delays[2] , None)\n            limit_cable_delay3 = None#(cable_delays[3] , None)\n\n        if antenna_position_guess_range_x is not None:\n            ant0_physical_limits_x = (antennas_phase_start[0][0] + manual_offset_ant0_x - antenna_position_guess_range_x ,antennas_phase_start[0][0] + manual_offset_ant0_x + antenna_position_guess_range_x)\n            ant1_physical_limits_x = (antennas_phase_start[1][0] + manual_offset_ant1_x - antenna_position_guess_range_x ,antennas_phase_start[1][0] + manual_offset_ant1_x + antenna_position_guess_range_x)\n            ant2_physical_limits_x = (antennas_phase_start[2][0] + manual_offset_ant2_x - antenna_position_guess_range_x ,antennas_phase_start[2][0] + manual_offset_ant2_x + antenna_position_guess_range_x)\n            ant3_physical_limits_x = (antennas_phase_start[3][0] + manual_offset_ant3_x - antenna_position_guess_range_x ,antennas_phase_start[3][0] + manual_offset_ant3_x + antenna_position_guess_range_x)\n        else:\n            ant0_physical_limits_x = None#None \n            ant1_physical_limits_x = None#(None,0.0) #Forced west of 0\n            ant2_physical_limits_x = None#None\n            ant3_physical_limits_x = None#(None,0.0) #Forced West of 0\n\n        if antenna_position_guess_range_y is not None:\n            ant0_physical_limits_y = (antennas_phase_start[0][1] + manual_offset_ant0_y - antenna_position_guess_range_y ,antennas_phase_start[0][1] + manual_offset_ant0_y + antenna_position_guess_range_y)\n            ant1_physical_limits_y = (antennas_phase_start[1][1] + manual_offset_ant1_y - antenna_position_guess_range_y ,antennas_phase_start[1][1] + manual_offset_ant1_y + antenna_position_guess_range_y)\n            ant2_physical_limits_y = (antennas_phase_start[2][1] + manual_offset_ant2_y - antenna_position_guess_range_y ,antennas_phase_start[2][1] + manual_offset_ant2_y + antenna_position_guess_range_y)\n            ant3_physical_limits_y = (antennas_phase_start[3][1] + manual_offset_ant3_y - antenna_position_guess_range_y ,antennas_phase_start[3][1] + manual_offset_ant3_y + antenna_position_guess_range_y)\n        else:\n            ant0_physical_limits_y = None#None \n            ant1_physical_limits_y = None#(None,0.0) #Forced west of 0\n            ant2_physical_limits_y = None#None\n            ant3_physical_limits_y = None#(None,0.0) #Forced West of 0\n\n        if antenna_position_guess_range_z is not None:\n            ant0_physical_limits_z = (antennas_phase_start[0][2] + manual_offset_ant0_z - antenna_position_guess_range_z ,antennas_phase_start[0][2] + manual_offset_ant0_z + antenna_position_guess_range_z)\n            ant1_physical_limits_z = (antennas_phase_start[1][2] + manual_offset_ant1_z - antenna_position_guess_range_z ,antennas_phase_start[1][2] + manual_offset_ant1_z + antenna_position_guess_range_z)\n            ant2_physical_limits_z = (antennas_phase_start[2][2] + manual_offset_ant2_z - antenna_position_guess_range_z ,antennas_phase_start[2][2] + manual_offset_ant2_z + antenna_position_guess_range_z)\n            ant3_physical_limits_z = (antennas_phase_start[3][2] + manual_offset_ant3_z - antenna_position_guess_range_z ,antennas_phase_start[3][2] + manual_offset_ant3_z + antenna_position_guess_range_z)\n        else:\n            ant0_physical_limits_z = None#None \n            ant1_physical_limits_z = None#(None,0.0) #Forced west of 0\n            ant2_physical_limits_z = None#None  $(antennas_phase_start[2][2] - 2.5 ,antennas_phase_start[2][2] + 2.5)#None#None\n            ant3_physical_limits_z = None#(None,0.0) #Forced West of 0\n\n        if random_offset_amount > 0:\n            print('RANDOMLY SHIFTING INPUT POSITIONS BY SPECIFIED AMOUNT:%0.2f m'%random_offset_amount)\n\n        initial_ant0_x = manual_offset_ant0_x + antennas_phase_start[0][0] + float(not fix_ant0_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant0_y = manual_offset_ant0_y + antennas_phase_start[0][1] + float(not fix_ant0_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant0_z = manual_offset_ant0_z + antennas_phase_start[0][2] + float(not fix_ant0_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant1_x = manual_offset_ant1_x + antennas_phase_start[1][0] + float(not fix_ant1_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant1_y = manual_offset_ant1_y + antennas_phase_start[1][1] + float(not fix_ant1_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant1_z = manual_offset_ant1_z + antennas_phase_start[1][2] + float(not fix_ant1_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant2_x = manual_offset_ant2_x + antennas_phase_start[2][0] + float(not fix_ant2_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant2_y = manual_offset_ant2_y + antennas_phase_start[2][1] + float(not fix_ant2_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant2_z = manual_offset_ant2_z + antennas_phase_start[2][2] + float(not fix_ant2_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant3_x = manual_offset_ant3_x + antennas_phase_start[3][0] + float(not fix_ant3_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant3_y = manual_offset_ant3_y + antennas_phase_start[3][1] + float(not fix_ant3_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n        initial_ant3_z = manual_offset_ant3_z + antennas_phase_start[3][2] + float(not fix_ant3_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n\n        initial_ant0_ENU = numpy.array([initial_ant0_x, initial_ant0_y, initial_ant0_z])\n        initial_ant1_ENU = numpy.array([initial_ant1_x, initial_ant1_y, initial_ant1_z])\n        initial_ant2_ENU = numpy.array([initial_ant2_x, initial_ant2_y, initial_ant2_z])\n        initial_ant3_ENU = numpy.array([initial_ant3_x, initial_ant3_y, initial_ant3_z])\n\n        ##########\n        # Define Chi^2\n        ##########\n\n        chi2_fig = plt.figure()\n        chi2_fig.canvas.set_window_title('Initial Positions')\n        chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n        if 0 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant0_x, initial_ant0_y, initial_ant0_z,c='r',alpha=0.5,label='Initial Ant0')\n        if 1 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant1_x, initial_ant1_y, initial_ant1_z,c='g',alpha=0.5,label='Initial Ant1')\n        if 2 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant2_x, initial_ant2_y, initial_ant2_z,c='b',alpha=0.5,label='Initial Ant2')\n        if 3 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant3_x, initial_ant3_y, initial_ant3_z,c='m',alpha=0.5,label='Initial Ant3')\n\n        chi2_ax.set_xlabel('East (m)',linespacing=10)\n        chi2_ax.set_ylabel('North (m)',linespacing=10)\n        chi2_ax.set_zlabel('Up (m)',linespacing=10)\n        \n        if False:\n            for key, enu in sources_ENU.items():\n                chi2_ax.scatter(enu[0], enu[1], enu[2],alpha=0.5,label=key)\n        else:\n            chi2_ax.dist = 10\n        plt.legend()\n\n\n        chi2_fig = plt.figure()\n        chi2_fig.canvas.set_window_title('Both')\n        chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n        if 0 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant0_x, initial_ant0_y, initial_ant0_z,c='r',alpha=0.5,label='Initial Ant0')\n        if 1 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant1_x, initial_ant1_y, initial_ant1_z,c='g',alpha=0.5,label='Initial Ant1')\n        if 2 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant2_x, initial_ant2_y, initial_ant2_z,c='b',alpha=0.5,label='Initial Ant2')\n        if 3 in included_antennas_lumped:\n            chi2_ax.scatter(initial_ant3_x, initial_ant3_y, initial_ant3_z,c='m',alpha=0.5,label='Initial Ant3')\n\n\n        if include_baseline_measurements:\n            #This will weight against differences that result in longer baselines than measured.   I.e. smaller number if current baseline > measured.  Large for current < measured. \n            #w = lambda measured, current : numpy.exp(measured - current)**2\n            measured_baselines = {'01':129*0.3048,\n                                  '02':163*0.3048,\n                                  '03':181*0.3048,\n                                  '12':151*0.3048,\n                                  '13':102*0.3048,\n                                  '23':85 *0.3048}\n\n        if True:\n            #Initial baselines just to be printed out\n            initial_baselines = {   '01':numpy.sqrt((initial_ant0_x - initial_ant1_x)**2 + (initial_ant0_y - initial_ant1_y)**2 + (initial_ant0_z - initial_ant1_z)**2),\\\n                                    '02':numpy.sqrt((initial_ant0_x - initial_ant2_x)**2 + (initial_ant0_y - initial_ant2_y)**2 + (initial_ant0_z - initial_ant2_z)**2),\\\n                                    '03':numpy.sqrt((initial_ant0_x - initial_ant3_x)**2 + (initial_ant0_y - initial_ant3_y)**2 + (initial_ant0_z - initial_ant3_z)**2),\\\n                                    '12':numpy.sqrt((initial_ant1_x - initial_ant2_x)**2 + (initial_ant1_y - initial_ant2_y)**2 + (initial_ant1_z - initial_ant2_z)**2),\\\n                                    '13':numpy.sqrt((initial_ant1_x - initial_ant3_x)**2 + (initial_ant1_y - initial_ant3_y)**2 + (initial_ant1_z - initial_ant3_z)**2),\\\n                                    '23':numpy.sqrt((initial_ant2_x - initial_ant3_x)**2 + (initial_ant2_y - initial_ant3_y)**2 + (initial_ant2_z - initial_ant3_z)**2)}\n            print('The initial baselines (specified by deploy_index = %s) with random offsets and manual adjustsments in meters are:'%(str(info.returnDefaultDeploy())))\n            print(initial_baselines)\n\n            for key in included_pulsers:\n                d0 = numpy.sqrt((pulser_locations_ENU[key][0] - initial_ant0_x)**2 + (pulser_locations_ENU[key][1] - initial_ant0_y)**2 + (pulser_locations_ENU[key][2] - initial_ant0_z)**2 ) #m\n                print('Pulser %s is %0.2f m away from Antenna 0'%(key, d0))\n\n        if unknown_source_dir_valley or include_sanity:\n            # Need correlator map class to use in chi^2.\n            chi_2_reader = Reader(datapath,valley_source_run)\n            chi_2_cor = Correlator(chi_2_reader,  upsample=cor_upsample, n_phi=181, range_phi_deg=(-90,90), n_theta=96, range_theta_deg=(85,180), waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True)\n            chi_2_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n            td_dicts = {}\n            for source_key in use_sources:\n                td_dicts[source_key] = {mode:{'[0, 1]' :  [time_delay_dict[source_key][0]], '[0, 2]' : [time_delay_dict[source_key][1]], '[0, 3]' : [time_delay_dict[source_key][2]], '[1, 2]' : [time_delay_dict[source_key][3]], '[1, 3]' : [time_delay_dict[source_key][4]], '[2, 3]' : [time_delay_dict[source_key][5]]}}\n\n        n_func = lambda v0, v1, v2 : - numpy.cross( v1 - v0 , v2 - v1 )/numpy.linalg.norm(- numpy.cross( v1 - v0 , v2 - v1 )) #Calculates normal vector of plane defined by 3 vectors.  \n        def rawChi2(ant0_x, ant0_y, ant0_z, ant1_x, ant1_y, ant1_z, ant2_x, ant2_y, ant2_z, ant3_x, ant3_y, ant3_z, cable_delay0, cable_delay1, cable_delay2, cable_delay3):\n            '''\n            This is a chi^2 that loops over locations from potential RFI, calculating expected time delays for those locations.  Then\n            it will compares those to the calculated time delays for suspected corresponding events.  \n            '''\n            try:\n                #Calculate distances (already converted to ns) from pulser to each antenna\n                chi_2 = 0.0\n                _cable_delays = [cable_delay0,cable_delay1,cable_delay2,cable_delay3]\n\n                if include_sanity or unknown_source_dir_valley:\n                    #For each of these I need updated maps\n                    ant0_ENU = numpy.array([ant0_x, ant0_y, ant0_z])\n                    ant1_ENU = numpy.array([ant1_x, ant1_y, ant1_z])\n                    ant2_ENU = numpy.array([ant2_x, ant2_y, ant2_z])\n                    ant3_ENU = numpy.array([ant3_x, ant3_y, ant3_z])\n                    if mode == 'hpol':\n                        chi_2_cor.overwriteCableDelays(cable_delay0, chi_2_cor.cable_delays[1], cable_delay1, chi_2_cor.cable_delays[3], cable_delay2, chi_2_cor.cable_delays[5], cable_delay3, chi_2_cor.cable_delays[7],verbose=False, suppress_time_delay_calculations=True)#WARNING, SUPRESSING CALCULATION OF TIME DELAY TABLE HERE, MAKE SURE IT HAPPENS WHEN ANTENNAS CHANGE\n                        chi_2_cor.overwriteAntennaLocations(chi_2_cor.A0_physical,chi_2_cor.A1_physical,chi_2_cor.A2_physical,chi_2_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,chi_2_cor.A0_vpol,chi_2_cor.A1_vpol,chi_2_cor.A2_vpol,chi_2_cor.A3_vpol,verbose=False, suppress_time_delay_calculations=False)\n                    else:\n                        chi_2_cor.overwriteCableDelays(chi_2_cor.cable_delays[0], cable_delay0, chi_2_cor.cable_delays[2], cable_delay1, chi_2_cor.cable_delays[4], cable_delay2, chi_2_cor.cable_delays[6], cable_delay3,verbose=False, suppress_time_delay_calculations=True)#WARNING, SUPRESSING CALCULATION OF TIME DELAY TABLE HERE, MAKE SURE IT HAPPENS WHEN ANTENNAS CHANGE\n                        chi_2_cor.overwriteAntennaLocations(chi_2_cor.A0_physical,chi_2_cor.A1_physical,chi_2_cor.A2_physical,chi_2_cor.A3_physical,chi_2_cor.A0_hpol,chi_2_cor.A1_hpol,chi_2_cor.A2_hpol,chi_2_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False, suppress_time_delay_calculations=False)\n\n\n                if unknown_source_dir_valley == False:\n                    #Assuming you know the source, calcualting time delays assuming that source direction.\n                    for key in use_sources:\n                            d0 = (numpy.sqrt((sources_ENU[key][0] - ant0_x)**2 + (sources_ENU[key][1] - ant0_y)**2 + (sources_ENU[key][2] - ant0_z)**2 )/c)*1.0e9 #ns\n                            d1 = (numpy.sqrt((sources_ENU[key][0] - ant1_x)**2 + (sources_ENU[key][1] - ant1_y)**2 + (sources_ENU[key][2] - ant1_z)**2 )/c)*1.0e9 #ns\n                            d2 = (numpy.sqrt((sources_ENU[key][0] - ant2_x)**2 + (sources_ENU[key][1] - ant2_y)**2 + (sources_ENU[key][2] - ant2_z)**2 )/c)*1.0e9 #ns\n                            d3 = (numpy.sqrt((sources_ENU[key][0] - ant3_x)**2 + (sources_ENU[key][1] - ant3_y)**2 + (sources_ENU[key][2] - ant3_z)**2 )/c)*1.0e9 #ns\n\n                            d = [d0,d1,d2,d3]\n\n                            for pair_index, pair in enumerate(pairs):\n                                if pairs_cut[pair_index]:\n                                    geometric_time_delay = (d[pair[0]] + _cable_delays[pair[0]]) - (d[pair[1]] + _cable_delays[pair[1]])\n\n                                    vals = ((geometric_time_delay - time_delay_dict[key][pair_index])**2)/time_delay_measurement_uncertainty_ns**2 #Assumes time delays are accurate\n                                    chi_2 += valley_weight*numpy.sum(vals)\n                            #import pdb; pdb.set_trace()\n                else:\n                    #Assuming you DON'T know the source, and using the precalculated time delays with the existing geometry to determine if the array points ANYWHERE for that source.\n                    for key in use_sources:\n                        # if key == 'E':\n                        #     distance_m = 2300\n                        #     zenith_cut_array_plane=[0,130]\n                        # else:\n                        #     distance_m = 1e6\n                        #     zenith_cut_array_plane=[0,92]\n\n                        # chi_2_cor.overwriteSourceDistance(distance_m, verbose=False, suppress_time_delay_calculations=False, debug=False)\n\n                        zenith_cut_array_plane=[0,92]\n\n                        if unknown_mode == 'strip':\n                            td_dict = td_dicts[key]\n\n                            mesh_azimuth_deg, mesh_elevation_deg, overlap_map = chi_2_cor.generateTimeDelayOverlapMap(mode, td_dict, overlap_window_ns, value_mode=overlap_value_mode, plot_map=False, mollweide=False,center_dir='E',window_title=None, include_baselines=include_baselines)\n                            linear_max_index, theta_best, phi_best, t_best_0subtract1, t_best_0subtract2, t_best_0subtract3, t_best_1subtract2, t_best_1subtract3, t_best_2subtract3 = chi_2_cor.mapMax(overlap_map, max_method=0, verbose=False, zenith_cut_ENU=[89,180], zenith_cut_array_plane=zenith_cut_array_plane, pol=mode) #This is used so that max value must be in reasonable window.\n                            max_value = overlap_map.flatten()[linear_max_index]\n                            #print('%0.4f / %0.4f = %0.3f'%(max_value, overlap_goal,max_value/overlap_goal))\n                            chi_2 += valley_weight*((max_value - overlap_goal)**2)/(overlap_error**2) \n                        elif unknown_mode == 'cor':\n                            eventid = time_delay_dict_eventids[key][0]\n                            \n                            #DON'T SWITCH TO HILBERT< IT CHANGES THE NORMALIZATION, AND I AM MATCHING THIS TO AN EXPECTED PEAK VALUE OF 1.\n                            mean_corr_values, max_possible_map_value = chi_2_cor.map(eventid, mode, include_baselines=include_baselines, plot_map=False, plot_corr=False, hilbert=False, interactive=False, max_method=0, waveforms=None, verbose=True, mollweide=False, zenith_cut_ENU=[90,180], zenith_cut_array_plane=zenith_cut_array_plane, center_dir='E', circle_zenith=None, circle_az=None, radius=1.0, time_delay_dict={},window_title=None,add_airplanes=False, return_max_possible_map_value=True)\n                            linear_max_index, theta_best, phi_best, t_best_0subtract1, t_best_0subtract2, t_best_0subtract3, t_best_1subtract2, t_best_1subtract3, t_best_2subtract3 = chi_2_cor.mapMax(mean_corr_values, max_method=0, verbose=False, zenith_cut_ENU=[89,180], zenith_cut_array_plane=zenith_cut_array_plane, pol=mode) #This is used so that max value must be in reasonable window.\n                            max_value = mean_corr_values.flatten()[linear_max_index]\n                            #print('%0.4f / %0.4f = %0.3f'%(max_value, max_possible_map_value,max_value/max_possible_map_value))\n                            chi_2 += valley_weight*((max_value - max_possible_map_value)**2)/(0.2**2) \n\n\n                if include_pulsers:\n                    for key in included_pulsers:\n                        d0 = (numpy.sqrt((pulser_locations_ENU[key][0] - ant0_x)**2 + (pulser_locations_ENU[key][1] - ant0_y)**2 + (pulser_locations_ENU[key][2] - ant0_z)**2 )/c)*1.0e9 #ns\n                        d1 = (numpy.sqrt((pulser_locations_ENU[key][0] - ant1_x)**2 + (pulser_locations_ENU[key][1] - ant1_y)**2 + (pulser_locations_ENU[key][2] - ant1_z)**2 )/c)*1.0e9 #ns\n                        d2 = (numpy.sqrt((pulser_locations_ENU[key][0] - ant2_x)**2 + (pulser_locations_ENU[key][1] - ant2_y)**2 + (pulser_locations_ENU[key][2] - ant2_z)**2 )/c)*1.0e9 #ns\n                        d3 = (numpy.sqrt((pulser_locations_ENU[key][0] - ant3_x)**2 + (pulser_locations_ENU[key][1] - ant3_y)**2 + (pulser_locations_ENU[key][2] - ant3_z)**2 )/c)*1.0e9 #ns\n\n                        d = [d0,d1,d2,d3]\n\n                        for pair_index, pair in enumerate(pairs):\n                            if pairs_cut[pair_index]:\n                                # pulser_time_delay_dict\n                                # pulser_time_delay_error_dict\n                                if pulser_time_delay_dict[key][pair_index][0][0] == pair[0] and pulser_time_delay_dict[key][pair_index][0][1] == pair[1]:\n                                    geometric_time_delay = (d[pair[0]] + _cable_delays[pair[0]]) - (d[pair[1]] + _cable_delays[pair[1]])\n                                    vals = ((geometric_time_delay - pulser_time_delay_dict[key][pair_index][1])**2) #Assumes time delays are accurate\n                                    chi_2 += pulser_weight*numpy.sum(vals)\n                                else:\n                                    print('PAIR INDICES DONT MATCH, SOMETHING IS WRONG')\n                if len(included_airplanes) > 0:\n                    # if mode == 'hpol':\n                    #     antennas_phase_start = antennas_phase_hpol\n                    # else:\n                    #     antennas_phase_start = antennas_phase_vpol\n\n                    for index, key in enumerate(list(calibrated_trigtime.keys())):\n                        if key not in included_airplanes:\n                            continue\n\n                        interpolated_plane_locations[key][:,0]\n                        interpolated_plane_locations[key][:,1]\n                        interpolated_plane_locations[key][:,2]\n\n                        d0 = (numpy.sqrt((interpolated_plane_locations[key][:,0] - ant0_x)**2 + (interpolated_plane_locations[key][:,1] - ant0_y)**2 + (interpolated_plane_locations[key][:,2] - ant0_z)**2 )/c)*1.0e9 #ns\n                        d1 = (numpy.sqrt((interpolated_plane_locations[key][:,0] - ant1_x)**2 + (interpolated_plane_locations[key][:,1] - ant1_y)**2 + (interpolated_plane_locations[key][:,2] - ant1_z)**2 )/c)*1.0e9 #ns\n                        d2 = (numpy.sqrt((interpolated_plane_locations[key][:,0] - ant2_x)**2 + (interpolated_plane_locations[key][:,1] - ant2_y)**2 + (interpolated_plane_locations[key][:,2] - ant2_z)**2 )/c)*1.0e9 #ns\n                        d3 = (numpy.sqrt((interpolated_plane_locations[key][:,0] - ant3_x)**2 + (interpolated_plane_locations[key][:,1] - ant3_y)**2 + (interpolated_plane_locations[key][:,2] - ant3_z)**2 )/c)*1.0e9 #ns\n\n                        d = [d0,d1,d2,d3]\n\n                        airplane_pair_cuts[key]\n                        # = time_shifts[0:6,:]\n\n\n                        #import pdb; pdb.set_trace()\n                        for pair_index, pair in enumerate(pairs):\n                            if airplane_pair_cuts[key][pair_index]:\n                                #td = \n                                geometric_time_delay = (d[pair[0]] + _cable_delays[pair[0]]) - (d[pair[1]] + _cable_delays[pair[1]])\n                                vals = ((geometric_time_delay - measured_plane_time_delays[key][pair_index])**2) #Assumes time delays are accurate\n                                chi_2 += airplane_weight*numpy.sum(vals)\n\n                if len(included_cw_sources) > 0:\n                    for key in included_cw_sources:\n                        d0 = (numpy.sqrt((cw_sources[key]['enu'][0] - ant0_x)**2 + (cw_sources[key]['enu'][1] - ant0_y)**2 + (cw_sources[key]['enu'][2] - ant0_z)**2 )/c)*1.0e9 #ns\n                        d1 = (numpy.sqrt((cw_sources[key]['enu'][0] - ant1_x)**2 + (cw_sources[key]['enu'][1] - ant1_y)**2 + (cw_sources[key]['enu'][2] - ant1_z)**2 )/c)*1.0e9 #ns\n                        d2 = (numpy.sqrt((cw_sources[key]['enu'][0] - ant2_x)**2 + (cw_sources[key]['enu'][1] - ant2_y)**2 + (cw_sources[key]['enu'][2] - ant2_z)**2 )/c)*1.0e9 #ns\n                        d3 = (numpy.sqrt((cw_sources[key]['enu'][0] - ant3_x)**2 + (cw_sources[key]['enu'][1] - ant3_y)**2 + (cw_sources[key]['enu'][2] - ant3_z)**2 )/c)*1.0e9 #ns\n\n                        d = [d0,d1,d2,d3]\n\n                        for pair_index, pair in enumerate(pairs):\n                            if pairs_cut[pair_index]:\n                                # pulser_time_delay_dict\n                                # pulser_time_delay_error_dict\n\n                                #time_delay_dict = {'hpol':{'[0, 1]' : [-77.6], '[0, 2]': [95.76], '[0, 3]': [-15.82], '[1, 2]': [173.4], '[1, 3]': [61.77], '[2, 3]': [-111.6]}}\n                                 #Single time delay value.\n\n                                geometric_time_delay = (d[pair[0]] + _cable_delays[pair[0]]) - (d[pair[1]] + _cable_delays[pair[1]])\n                                chi_2 += numpy.min(cw_weight*((geometric_time_delay - cw_sources[key]['time_delay_dict'][mode]['[%i, %i]'%(pair[0],pair[1])])**2)) #Assumes time delays are accurate, uses only best minimized time delay from each baseline (min)\n\n\n\n\n\n                if include_baseline_measurements:\n                    #This will weight against differences that result in longer baselines than measured.   I.e. smaller number if current baseline > measured.  Large for current < measured. \n                    current_baselines = {   '01':numpy.sqrt((ant0_x - ant1_x)**2 + (ant0_y - ant1_y)**2 + (ant0_z - ant1_z)**2),\\\n                                            '02':numpy.sqrt((ant0_x - ant2_x)**2 + (ant0_y - ant2_y)**2 + (ant0_z - ant2_z)**2),\\\n                                            '03':numpy.sqrt((ant0_x - ant3_x)**2 + (ant0_y - ant3_y)**2 + (ant0_z - ant3_z)**2),\\\n                                            '12':numpy.sqrt((ant1_x - ant2_x)**2 + (ant1_y - ant2_y)**2 + (ant1_z - ant2_z)**2),\\\n                                            '13':numpy.sqrt((ant1_x - ant3_x)**2 + (ant1_y - ant3_y)**2 + (ant1_z - ant3_z)**2),\\\n                                            '23':numpy.sqrt((ant2_x - ant3_x)**2 + (ant2_y - ant3_y)**2 + (ant2_z - ant3_z)**2)}\n                    \n                    #Adds chi^2 as soon as any baseline exceeds that measured with a tape measure.\n                    #chi_2 += 100*numpy.any([(current_baselines['01'] - measured_baselines['01']) > baseline_upper_bound_tolerance, (current_baselines['02'] - measured_baselines['02']) > baseline_upper_bound_tolerance, (current_baselines['03'] - measured_baselines['03']) > baseline_upper_bound_tolerance, (current_baselines['12'] - measured_baselines['12']) > baseline_upper_bound_tolerance, (current_baselines['13'] - measured_baselines['13']) > baseline_upper_bound_tolerance, (current_baselines['23'] - measured_baselines['23']) > baseline_upper_bound_tolerance])\n                    for pair_index, pair in enumerate(pairs):\n                        if pairs_cut[pair_index]:\n                            key = str(int(pair[0])) + str(int(pair[1]))\n                            chi_2 += ((current_baselines[key] - measured_baselines[key])**2)/(baseline_measurement_uncertainty_m**2)\n\n                if limit_array_plane_azimuth_range == True:\n                    plane_normal_vector = n_func(numpy.array([ant0_x, ant0_y, ant0_z]),     numpy.array([ant2_x, ant2_y, ant2_z]),     (numpy.array([ant0_x, ant0_y, ant0_z])     + numpy.array([ant3_x, ant3_y, ant3_z]))/2.0)\n                    array_plane_az = numpy.rad2deg(numpy.arctan2(plane_normal_vector[1],plane_normal_vector[0]))\n                    chi_2 += numpy.max(numpy.abs(array_plane_az) - allowed_array_plane_azimuth_range ,0) #Within range 0 added, outside is adds the difference in degrees outside of the range.  \n                \n                if include_sanity:\n                    for pair_index, pair in enumerate(pairs):\n                        if pairs_cut[pair_index]:\n                            for key in use_sources:\n                                if mode == 'hpol':\n                                    if pair_index == 0: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_0subtract1)) - numpy.abs(time_delay_dict[key][0])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 1: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_0subtract2)) - numpy.abs(time_delay_dict[key][1])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 2: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_0subtract3)) - numpy.abs(time_delay_dict[key][2])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 3: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_1subtract2)) - numpy.abs(time_delay_dict[key][3])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 4: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_1subtract3)) - numpy.abs(time_delay_dict[key][4])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 5: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_2subtract3)) - numpy.abs(time_delay_dict[key][5])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    \n                                    if include_pulsers:\n                                        for key in included_pulsers:\n                                            if pair_index == 0: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_0subtract1)) - numpy.abs(pulser_time_delay_dict[key][0][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 1: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_0subtract2)) - numpy.abs(pulser_time_delay_dict[key][1][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 2: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_0subtract3)) - numpy.abs(pulser_time_delay_dict[key][2][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 3: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_1subtract2)) - numpy.abs(pulser_time_delay_dict[key][3][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 4: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_1subtract3)) - numpy.abs(pulser_time_delay_dict[key][4][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 5: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_hpol_2subtract3)) - numpy.abs(pulser_time_delay_dict[key][5][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                else:\n                                    if pair_index == 0: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_0subtract1)) - numpy.abs(time_delay_dict[key][0])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 1: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_0subtract2)) - numpy.abs(time_delay_dict[key][1])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 2: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_0subtract3)) - numpy.abs(time_delay_dict[key][2])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 3: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_1subtract2)) - numpy.abs(time_delay_dict[key][3])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 4: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_1subtract3)) - numpy.abs(time_delay_dict[key][4])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    if pair_index == 5: \n                                        #This can indicate that the baseline is not possible to create. \n                                        difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_2subtract3)) - numpy.abs(time_delay_dict[key][5])\n                                        if difference < 0:\n                                            chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                    \n                                    if include_pulsers:\n                                        for key in included_pulsers:\n                                            if pair_index == 0: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_0subtract1)) - numpy.abs(pulser_time_delay_dict[key][0][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 1: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_0subtract2)) - numpy.abs(pulser_time_delay_dict[key][1][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 2: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_0subtract3)) - numpy.abs(pulser_time_delay_dict[key][2][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 3: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_1subtract2)) - numpy.abs(pulser_time_delay_dict[key][3][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 4: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_1subtract3)) - numpy.abs(pulser_time_delay_dict[key][4][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n                                            if pair_index == 5: \n                                                #This can indicate that the baseline is not possible to create. \n                                                difference = numpy.max(numpy.abs(chi_2_cor.t_vpol_2subtract3)) - numpy.abs(pulser_time_delay_dict[key][5][1])\n                                                if difference < 0:\n                                                    chi_2 -= 100*difference #difference is negative, so subtracting negative is adding to chi^2 weighting against solution that results in maximum achievable baselines being too large.\n\n\n                    #chi_2 += max(ant2_z - ant1_z,0) #If antenna 2 is lower than antenna 1 then it will add to chi^2 linearly as that happens.  \n                print(chi_2)\n                return chi_2\n            except Exception as e:\n                print('Error in rawChi2')\n                print(e)\n                exc_type, exc_obj, exc_tb = sys.exc_info()\n                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n                print(exc_type, fname, exc_tb.tb_lineno)\n\n\n        \n        #-12 ft on pulser locations relative to antennas to account for additional mast elevation.\n        \n        \n        #rawChi2(ant0_x=antennas_phase_start[0][0], ant0_y=antennas_phase_start[0][1], ant0_z=antennas_phase_start[0][2], ant1_x=antennas_phase_start[1][0], ant1_y=antennas_phase_start[1][1], ant1_z=antennas_phase_start[1][2], ant2_x=antennas_phase_start[2][0], ant2_y=antennas_phase_start[2][1], ant2_z=antennas_phase_start[2][2], ant3_x=antennas_phase_start[3][0], ant3_y=antennas_phase_start[3][1], ant3_z=antennas_phase_start[3][2])\n        try:\n            m = Minuit(     rawChi2,\\\n                            ant0_x=initial_ant0_x,\\\n                            ant0_y=initial_ant0_y,\\\n                            ant0_z=initial_ant0_z,\\\n                            ant1_x=initial_ant1_x,\\\n                            ant1_y=initial_ant1_y,\\\n                            ant1_z=initial_ant1_z,\\\n                            ant2_x=initial_ant2_x,\\\n                            ant2_y=initial_ant2_y,\\\n                            ant2_z=initial_ant2_z,\\\n                            ant3_x=initial_ant3_x,\\\n                            ant3_y=initial_ant3_y,\\\n                            ant3_z=initial_ant3_z,\\\n                            cable_delay0=cable_delays[0],\\\n                            cable_delay1=cable_delays[1],\\\n                            cable_delay2=cable_delays[2],\\\n                            cable_delay3=cable_delays[3],\\\n                            error_ant0_x=initial_step_x,\\\n                            error_ant0_y=initial_step_y,\\\n                            error_ant0_z=initial_step_z,\\\n                            error_ant1_x=initial_step_x,\\\n                            error_ant1_y=initial_step_y,\\\n                            error_ant1_z=initial_step_z,\\\n                            error_ant2_x=initial_step_x,\\\n                            error_ant2_y=initial_step_y,\\\n                            error_ant2_z=initial_step_z,\\\n                            error_ant3_x=initial_step_x,\\\n                            error_ant3_y=initial_step_y,\\\n                            error_ant3_z=initial_step_z,\\\n                            error_cable_delay0=initial_step_cable_delay,\\\n                            error_cable_delay1=initial_step_cable_delay,\\\n                            error_cable_delay2=initial_step_cable_delay,\\\n                            error_cable_delay3=initial_step_cable_delay,\\\n                            errordef = 1.0,\\\n                            limit_ant0_x=ant0_physical_limits_x,\\\n                            limit_ant0_y=ant0_physical_limits_y,\\\n                            limit_ant0_z=ant0_physical_limits_z,\\\n                            limit_ant1_x=ant1_physical_limits_x,\\\n                            limit_ant1_y=ant1_physical_limits_y,\\\n                            limit_ant1_z=ant1_physical_limits_z,\\\n                            limit_ant2_x=ant2_physical_limits_x,\\\n                            limit_ant2_y=ant2_physical_limits_y,\\\n                            limit_ant2_z=ant2_physical_limits_z,\\\n                            limit_ant3_x=ant3_physical_limits_x,\\\n                            limit_ant3_y=ant3_physical_limits_y,\\\n                            limit_ant3_z=ant3_physical_limits_z,\\\n                            limit_cable_delay0=limit_cable_delay0,\\\n                            limit_cable_delay1=limit_cable_delay1,\\\n                            limit_cable_delay2=limit_cable_delay2,\\\n                            limit_cable_delay3=limit_cable_delay3,\\\n                            fix_ant0_x=fix_ant0_x,\\\n                            fix_ant0_y=fix_ant0_y,\\\n                            fix_ant0_z=fix_ant0_z,\\\n                            fix_ant1_x=fix_ant1_x,\\\n                            fix_ant1_y=fix_ant1_y,\\\n                            fix_ant1_z=fix_ant1_z,\\\n                            fix_ant2_x=fix_ant2_x,\\\n                            fix_ant2_y=fix_ant2_y,\\\n                            fix_ant2_z=fix_ant2_z,\\\n                            fix_ant3_x=fix_ant3_x,\\\n                            fix_ant3_y=fix_ant3_y,\\\n                            fix_ant3_z=fix_ant3_z,\\\n                            fix_cable_delay0=fix_cable_delay0,\\\n                            fix_cable_delay1=fix_cable_delay1,\\\n                            fix_cable_delay2=fix_cable_delay2,\\\n                            fix_cable_delay3=fix_cable_delay3)\n            result = m.migrad(resume=False)\n        except Exception as e:\n            print(e)\n            print('Attempting setup of iminuit again, but assuming newer version of imnuit.')\n            m = Minuit(     rawChi2,\\\n                            ant0_x=initial_ant0_x,\\\n                            ant0_y=initial_ant0_y,\\\n                            ant0_z=initial_ant0_z,\\\n                            ant1_x=initial_ant1_x,\\\n                            ant1_y=initial_ant1_y,\\\n                            ant1_z=initial_ant1_z,\\\n                            ant2_x=initial_ant2_x,\\\n                            ant2_y=initial_ant2_y,\\\n                            ant2_z=initial_ant2_z,\\\n                            ant3_x=initial_ant3_x,\\\n                            ant3_y=initial_ant3_y,\\\n                            ant3_z=initial_ant3_z,\\\n                            cable_delay0=cable_delays[0],\\\n                            cable_delay1=cable_delays[1],\\\n                            cable_delay2=cable_delays[2],\\\n                            cable_delay3=cable_delays[3])\n\n            m.errors['ant0_x'] = initial_step_x\n            m.errors['ant0_y'] = initial_step_y\n            m.errors['ant0_z'] = initial_step_z\n            m.errors['ant1_x'] = initial_step_x\n            m.errors['ant1_y'] = initial_step_y\n            m.errors['ant1_z'] = initial_step_z\n            m.errors['ant2_x'] = initial_step_x\n            m.errors['ant2_y'] = initial_step_y\n            m.errors['ant2_z'] = initial_step_z\n            m.errors['ant3_x'] = initial_step_x\n            m.errors['ant3_y'] = initial_step_y\n            m.errors['ant3_z'] = initial_step_z\n            m.errors['cable_delay0'] = initial_step_cable_delay\n            m.errors['cable_delay1'] = initial_step_cable_delay\n            m.errors['cable_delay2'] = initial_step_cable_delay\n            m.errors['cable_delay3'] = initial_step_cable_delay\n            m.errordef = 1.0\n            m.limits['ant0_x'] = ant0_physical_limits_x\n            m.limits['ant0_y'] = ant0_physical_limits_y\n            m.limits['ant0_z'] = ant0_physical_limits_z\n            m.limits['ant1_x'] = ant1_physical_limits_x\n            m.limits['ant1_y'] = ant1_physical_limits_y\n            m.limits['ant1_z'] = ant1_physical_limits_z\n            m.limits['ant2_x'] = ant2_physical_limits_x\n            m.limits['ant2_y'] = ant2_physical_limits_y\n            m.limits['ant2_z'] = ant2_physical_limits_z\n            m.limits['ant3_x'] = ant3_physical_limits_x\n            m.limits['ant3_y'] = ant3_physical_limits_y\n            m.limits['ant3_z'] = ant3_physical_limits_z\n            m.limits['cable_delay0'] = limit_cable_delay0\n            m.limits['cable_delay1'] = limit_cable_delay1\n            m.limits['cable_delay2'] = limit_cable_delay2\n            m.limits['cable_delay3'] = limit_cable_delay3\n            m.fixed['ant0_x'] = fix_ant0_x\n            m.fixed['ant0_y'] = fix_ant0_y\n            m.fixed['ant0_z'] = fix_ant0_z\n            m.fixed['ant1_x'] = fix_ant1_x\n            m.fixed['ant1_y'] = fix_ant1_y\n            m.fixed['ant1_z'] = fix_ant1_z\n            m.fixed['ant2_x'] = fix_ant2_x\n            m.fixed['ant2_y'] = fix_ant2_y\n            m.fixed['ant2_z'] = fix_ant2_z\n            m.fixed['ant3_x'] = fix_ant3_x\n            m.fixed['ant3_y'] = fix_ant3_y\n            m.fixed['ant3_z'] = fix_ant3_z\n            m.fixed['cable_delay0'] = fix_cable_delay0\n            m.fixed['cable_delay1'] = fix_cable_delay1\n            m.fixed['cable_delay2'] = fix_cable_delay2\n            m.fixed['cable_delay3'] = fix_cable_delay3\n\n            result = m.migrad()\n\n\n        print(result)\n        m.hesse()\n        if False:\n            m.minos()\n            pprint(m.get_fmin())\n        else:\n            try:\n                m.minos()\n                pprint(m.get_fmin())\n            except:\n                print('MINOS FAILED, NOT VALID SOLUTION.')\n        print('\\a')\n\n        # m.draw_mncontour('ant1_x','ant1_y')\n\n        for antenna in range(4):\n            fig = plt.figure()\n            fig.canvas.set_window_title('Ant %i chi^2'%antenna)\n            for index, key in enumerate(['ant%i_x'%antenna,'ant%i_y'%antenna,'ant%i_z'%antenna]):\n                plt.subplot(1,3,index + 1)\n                m.draw_profile(key)\n\n        if cable_delay_guess_range is not None:\n            fig = plt.figure()\n            fig.canvas.set_window_title('Cable Delays')\n            for antenna in range(4):\n                plt.subplot(2,2,antenna + 1)\n                m.draw_profile('cable_delay%i'%antenna)\n\n\n\n        #12 variables\n        ant0_phase_x = m.values['ant0_x']\n        ant0_phase_y = m.values['ant0_y']\n        ant0_phase_z = m.values['ant0_z']\n        ant0_cable_delay = m.values['cable_delay0']\n\n        ant1_phase_x = m.values['ant1_x']\n        ant1_phase_y = m.values['ant1_y']\n        ant1_phase_z = m.values['ant1_z']\n        ant1_cable_delay = m.values['cable_delay1']\n\n        ant2_phase_x = m.values['ant2_x']\n        ant2_phase_y = m.values['ant2_y']\n        ant2_phase_z = m.values['ant2_z']\n        ant2_cable_delay = m.values['cable_delay2']\n\n        ant3_phase_x = m.values['ant3_x']\n        ant3_phase_y = m.values['ant3_y']\n        ant3_phase_z = m.values['ant3_z']\n        ant3_cable_delay = m.values['cable_delay3']\n\n        ant0_ENU = numpy.array([ant0_phase_x, ant0_phase_y, ant0_phase_z]) #initial_ant0_ENU\n        ant1_ENU = numpy.array([ant1_phase_x, ant1_phase_y, ant1_phase_z])\n        ant2_ENU = numpy.array([ant2_phase_x, ant2_phase_y, ant2_phase_z])\n        ant3_ENU = numpy.array([ant3_phase_x, ant3_phase_y, ant3_phase_z])\n        resulting_cable_delays = numpy.array([ant0_cable_delay,ant1_cable_delay,ant2_cable_delay,ant3_cable_delay])\n\n        output_antennas_phase = {0:ant0_ENU, 1:ant1_ENU, 2:ant2_ENU, 3:ant3_ENU}\n\n        chi2_ax.plot([initial_ant0_x , ant0_phase_x], [initial_ant0_y , ant0_phase_y], [initial_ant0_z , ant0_phase_z],c='r',alpha=0.5,linestyle='--')\n        chi2_ax.plot([initial_ant1_x , ant1_phase_x], [initial_ant1_y , ant1_phase_y], [initial_ant1_z , ant1_phase_z],c='g',alpha=0.5,linestyle='--')\n        chi2_ax.plot([initial_ant2_x , ant2_phase_x], [initial_ant2_y , ant2_phase_y], [initial_ant2_z , ant2_phase_z],c='b',alpha=0.5,linestyle='--')\n        chi2_ax.plot([initial_ant3_x , ant3_phase_x], [initial_ant3_y , ant3_phase_y], [initial_ant3_z , ant3_phase_z],c='m',alpha=0.5,linestyle='--')\n\n        chi2_ax.scatter(ant0_phase_x, ant0_phase_y, ant0_phase_z,marker='*',c='r',alpha=0.5,label='Final Ant0')\n        chi2_ax.scatter(ant1_phase_x, ant1_phase_y, ant1_phase_z,marker='*',c='g',alpha=0.5,label='Final Ant1')\n        chi2_ax.scatter(ant2_phase_x, ant2_phase_y, ant2_phase_z,marker='*',c='b',alpha=0.5,label='Final Ant2')\n        chi2_ax.scatter(ant3_phase_x, ant3_phase_y, ant3_phase_z,marker='*',c='m',alpha=0.5,label='Final Ant3')\n        \n        chi2_ax.set_xlabel('East (m)',linespacing=10)\n        chi2_ax.set_ylabel('North (m)',linespacing=10)\n        chi2_ax.set_zlabel('Up (m)',linespacing=10)\n        chi2_ax.dist = 10\n        plt.legend()\n\n\n\n        chi2_fig = plt.figure()\n        chi2_fig.canvas.set_window_title('Final Positions')\n        chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n        if 0 in included_antennas_lumped:\n            chi2_ax.scatter(ant0_phase_x, ant0_phase_y, ant0_phase_z,marker='*',c='r',alpha=0.5,label='Final Ant0')\n        if 1 in included_antennas_lumped:\n            chi2_ax.scatter(ant1_phase_x, ant1_phase_y, ant1_phase_z,marker='*',c='g',alpha=0.5,label='Final Ant1')\n        if 2 in included_antennas_lumped:\n            chi2_ax.scatter(ant2_phase_x, ant2_phase_y, ant2_phase_z,marker='*',c='b',alpha=0.5,label='Final Ant2')\n        if 3 in included_antennas_lumped:\n            chi2_ax.scatter(ant3_phase_x, ant3_phase_y, ant3_phase_z,marker='*',c='m',alpha=0.5,label='Final Ant3')\n\n        chi2_ax.set_xlabel('East (m)',linespacing=10)\n        chi2_ax.set_ylabel('North (m)',linespacing=10)\n        chi2_ax.set_zlabel('Up (m)',linespacing=10)\n        chi2_ax.dist = 10\n        plt.legend()\n\n        sources_ENU, data_slicer_cut_dict = info.loadValleySourcesENU() #Plot all potential sources\n        reader = Reader(datapath,valley_source_run)\n        for source_key, cut_dict in data_slicer_cut_dict.items():\n            if source_key in only_plot:\n                #Accounting for potentially shifted antenna 0.  Centering ENU to that for calculations.\n                original_sources_ENU = numpy.array([sources_ENU[source_key][0] , sources_ENU[source_key][1] , sources_ENU[source_key][2]])\n                original_distance_m = numpy.linalg.norm(original_sources_ENU)\n                original_zenith_deg = numpy.rad2deg(numpy.arccos(original_sources_ENU[2]/original_distance_m))\n                original_elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(original_sources_ENU[2]/original_distance_m))\n                original_azimuth_deg = numpy.rad2deg(numpy.arctan2(original_sources_ENU[1],original_sources_ENU[0]))\n\n                sources_ENU_new = numpy.array([sources_ENU[source_key][0] - ant0_ENU[0] , sources_ENU[source_key][1] - ant0_ENU[1] , sources_ENU[source_key][2] - ant0_ENU[2]])\n                distance_m = numpy.linalg.norm(sources_ENU_new)\n                zenith_deg = numpy.rad2deg(numpy.arccos(sources_ENU_new[2]/distance_m))\n                elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(sources_ENU_new[2]/distance_m))\n                azimuth_deg = numpy.rad2deg(numpy.arctan2(sources_ENU_new[1],sources_ENU_new[0]))\n\n                #Only used for map.  Hists use higher resolution on tighter area.\n                map_resolution = 0.25 #degrees\n                range_phi_deg=(-180, 180)\n                range_theta_deg=(0,180)\n                n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                \n                cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                #Want cor to be the initial correlator, which requires moving antennas to the positions they actually started at.\n                if mode == 'hpol':\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,cor.A0_vpol,cor.A1_vpol,cor.A2_vpol,cor.A3_vpol,verbose=False)\n                else:\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cor.A0_hpol,cor.A1_hpol,cor.A2_hpol,cor.A3_hpol,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,verbose=False)\n\n\n                adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n                \n                if mode == 'hpol':\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                    adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                else:\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                    adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])\n                \n                if source_key == 'Solar Plant':\n                    measured_baselines = {'01':129*0.3048,\n                                          '02':163*0.3048,\n                                          '03':181*0.3048,\n                                          '12':151*0.3048,\n                                          '13':102*0.3048,\n                                          '23':85 *0.3048}\n                    time_delay_dict_solarplant = [-125.95932801, -126.69556678, -180.32099852,   -0.81123762,  -54.37417032,  -53.60793201]\n                    print('min = %0.3f, max = %0.3f, expected = %0.3f, physical = %0.3f'%(numpy.min(adjusted_cor.t_hpol_0subtract1),numpy.max(adjusted_cor.t_hpol_0subtract1),time_delay_dict_solarplant[0], 1e9*measured_baselines['01']/c))\n                    print('min = %0.3f, max = %0.3f, expected = %0.3f, physical = %0.3f'%(numpy.min(adjusted_cor.t_hpol_0subtract2),numpy.max(adjusted_cor.t_hpol_0subtract2),time_delay_dict_solarplant[1], 1e9*measured_baselines['02']/c))\n                    print('min = %0.3f, max = %0.3f, expected = %0.3f, physical = %0.3f'%(numpy.min(adjusted_cor.t_hpol_0subtract3),numpy.max(adjusted_cor.t_hpol_0subtract3),time_delay_dict_solarplant[2], 1e9*measured_baselines['03']/c))\n                    print('min = %0.3f, max = %0.3f, expected = %0.3f, physical = %0.3f'%(numpy.min(adjusted_cor.t_hpol_1subtract2),numpy.max(adjusted_cor.t_hpol_1subtract2),time_delay_dict_solarplant[3], 1e9*measured_baselines['12']/c))\n                    print('min = %0.3f, max = %0.3f, expected = %0.3f, physical = %0.3f'%(numpy.min(adjusted_cor.t_hpol_1subtract3),numpy.max(adjusted_cor.t_hpol_1subtract3),time_delay_dict_solarplant[4], 1e9*measured_baselines['13']/c))\n                    print('min = %0.3f, max = %0.3f, expected = %0.3f, physical = %0.3f'%(numpy.min(adjusted_cor.t_hpol_2subtract3),numpy.max(adjusted_cor.t_hpol_2subtract3),time_delay_dict_solarplant[5], 1e9*measured_baselines['23']/c))\n\n                if plot_expected_direction == False:\n                    zenith_deg = None\n                    azimuth_deg = None\n                if plot_time_delays_on_maps:\n                    td_dict = {mode:{'[0, 1]' :  [time_delay_dict[source_key][0]], '[0, 2]' : [time_delay_dict[source_key][1]], '[0, 3]' : [time_delay_dict[source_key][2]], '[1, 2]' : [time_delay_dict[source_key][3]], '[1, 3]' : [time_delay_dict[source_key][4]], '[2, 3]' : [time_delay_dict[source_key][5]]}}\n                else:\n                    td_dict = {}\n\n                if plot_overlap:\n                    adjusted_cor.generateTimeDelayOverlapMap(mode, td_dict, overlap_window_ns, plot_map=True, mollweide=False,center_dir='E',window_title='Adjusted Map Overlap\\n%s'%source_key, include_baselines=include_baselines)\n\n                ds.addROI(source_key,cut_dict)\n                roi_eventids = numpy.intersect1d(ds.getCutsFromROI(source_key),_eventids)\n                roi_impulsivity = ds.getDataFromParam(roi_eventids,'impulsivity_h')\n                roi_impulsivity_sort = numpy.argsort(roi_impulsivity) #NOT REVERSED\n                eventid = roi_eventids[roi_impulsivity_sort[-1]]\n                \n                #mean_corr_values, fig, ax = cor.map(eventid, mode, plot_map=True, plot_corr=False, hilbert=False, zenith_cut_array_plane=None, interactive=True,circle_zenith=original_zenith_deg, circle_az=original_azimuth_deg, time_delay_dict=td_dict)\n                adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(eventid, mode, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict,window_title=source_key, include_baselines=include_baselines)\n                #adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(eventid, mode, plot_map=True, plot_corr=False, hilbert=True, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict,window_title=source_key)\n                \n                if plot_histograms:\n                    map_resolution = 0.25 #degrees\n                    range_phi_deg=(azimuth_deg - 10, azimuth_deg + 10)\n                    range_theta_deg=(zenith_deg - 10,zenith_deg + 10)\n                    n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                    n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                    \n                    cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                    cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    if mode == 'hpol':\n                        cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,cor.A0_vpol,cor.A1_vpol,cor.A2_vpol,cor.A3_vpol,verbose=False)\n                    else:\n                        cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cor.A0_hpol,cor.A1_hpol,cor.A2_hpol,cor.A3_hpol,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,verbose=False)\n\n                    adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                    adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    if mode == 'hpol':\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                        adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                    else:\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                        adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])\n\n\n                    hist = adjusted_cor.histMapPeak(numpy.sort(numpy.random.choice(roi_eventids,min(limit_events,len(roi_eventids)))), mode, plot_map=True, hilbert=False, max_method=0, use_weight=False, mollweide=False, center_dir='E', radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,100],circle_zenith=zenith_deg, circle_az=azimuth_deg, window_title='Hist ' + source_key, include_baselines=include_baselines,iterate_sub_baselines=iterate_sub_baselines)\n\n        if include_pulsers:\n            \n            ant0_ENU = numpy.array([ant0_phase_x, ant0_phase_y, ant0_phase_z])\n            ant1_ENU = numpy.array([ant1_phase_x, ant1_phase_y, ant1_phase_z])\n            ant2_ENU = numpy.array([ant2_phase_x, ant2_phase_y, ant2_phase_z])\n            ant3_ENU = numpy.array([ant3_phase_x, ant3_phase_y, ant3_phase_z])\n\n            for key in included_pulsers:\n                #Calculate old and new geometries\n                #Distance needed when calling correlator, as it uses that distance.\n                original_pulser_ENU = numpy.array([pulser_locations_ENU[key][0] , pulser_locations_ENU[key][1] , pulser_locations_ENU[key][2]])\n                original_distance_m = numpy.linalg.norm(original_pulser_ENU)\n                original_zenith_deg = numpy.rad2deg(numpy.arccos(original_pulser_ENU[2]/original_distance_m))\n                original_elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(original_pulser_ENU[2]/original_distance_m))\n                original_azimuth_deg = numpy.rad2deg(numpy.arctan2(original_pulser_ENU[1],original_pulser_ENU[0]))\n\n                pulser_ENU_new = numpy.array([pulser_locations_ENU[key][0] - ant0_ENU[0] , pulser_locations_ENU[key][1] - ant0_ENU[1] , pulser_locations_ENU[key][2] - ant0_ENU[2]])\n                distance_m = numpy.linalg.norm(pulser_ENU_new)\n                zenith_deg = numpy.rad2deg(numpy.arccos(pulser_ENU_new[2]/distance_m))\n                elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(pulser_ENU_new[2]/distance_m))\n                azimuth_deg = numpy.rad2deg(numpy.arctan2(pulser_ENU_new[1],pulser_ENU_new[0]))\n\n                map_resolution = 0.25 #degrees\n                range_phi_deg = (-90, 90)\n                range_theta_deg = (0,180)\n                n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                \n                #Load in correct reader for this pulser\n                reader = Reader(datapath,int(key.replace('run','')))\n                # cor_upsample =  len(reader.t())\n                if False and key == 'run1511':\n                    cor = Correlator(reader,  upsample=cor_upsample, n_phi=100,range_phi_deg=[-180,180], n_theta=50,range_theta_deg=[0,180], waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                    cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    if mode == 'hpol':\n                        cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,cor.A0_vpol,cor.A1_vpol,cor.A2_vpol,cor.A3_vpol,verbose=False)\n                    else:\n                        cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cor.A0_hpol,cor.A1_hpol,cor.A2_hpol,cor.A3_hpol,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,verbose=False)\n                    cor.generateTimeIndices(debug=True)\n                \n                cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                if mode == 'hpol':\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,cor.A0_vpol,cor.A1_vpol,cor.A2_vpol,cor.A3_vpol,verbose=False)\n                else:\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cor.A0_hpol,cor.A1_hpol,cor.A2_hpol,cor.A3_hpol,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,verbose=False)\n\n\n                adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                if mode == 'hpol':\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                    adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                else:\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                    adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])                    \n\n                if plot_expected_direction == False:\n                    zenith_deg = None\n                    azimuth_deg = None\n                if plot_time_delays_on_maps:\n                    # if key == 'run1509':\n                    #     td_dict = {mode:{'[0, 1]' :  [pulser_time_delay_dict[key][0][1]], '[0, 2]' : [pulser_time_delay_dict[key][1][1]], '[0, 3]' : [pulser_time_delay_dict[key][2][1]], '[1, 2]' : [pulser_time_delay_dict[key][3][1]], '[1, 3]' : [pulser_time_delay_dict[key][4][1]], '[2, 3]' : [-99.04]}}\n                    #     print(td_dict)\n                    # else:\n                    td_dict = {mode:{'[0, 1]' :  [pulser_time_delay_dict[key][0][1]], '[0, 2]' : [pulser_time_delay_dict[key][1][1]], '[0, 3]' : [pulser_time_delay_dict[key][2][1]], '[1, 2]' : [pulser_time_delay_dict[key][3][1]], '[1, 3]' : [pulser_time_delay_dict[key][4][1]], '[2, 3]' : [pulser_time_delay_dict[key][5][1]]}}\n                else:\n                    td_dict = {}\n\n                eventid = numpy.random.choice(known_pulser_ids[key][mode])\n                \n                #mean_corr_values, fig, ax = cor.map(eventid, mode, plot_map=True, plot_corr=False, hilbert=False, zenith_cut_array_plane=None, interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict)\n                adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(eventid, mode, include_baselines=include_baselines, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict)\n                #adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(eventid, mode, plot_map=True, plot_corr=False, hilbert=True, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict)\n\n                if False and key == 'run1511':\n                    adjusted_cor.overwriteSourceDistance(1e6, verbose=True, suppress_time_delay_calculations=False,debug=False)\n                    adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(eventid, mode, include_baselines=include_baselines, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict)\n\n                if plot_histograms:\n                    map_resolution = 0.1 #degrees\n                    range_phi_deg=(azimuth_deg - 10, azimuth_deg + 10)\n                    range_theta_deg=(zenith_deg - 10,zenith_deg + 10)\n                    n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                    n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                    \n                    #Load in correct reader for this pulser\n                    reader = Reader(datapath,int(key.replace('run','')))\n                    # cor_upsample =  len(reader.t())\n                    \n                    cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                    cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                    adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    if mode == 'hpol':\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                        adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                    else:\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                        adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])                    \n\n                    hist = adjusted_cor.histMapPeak(numpy.sort(numpy.random.choice(known_pulser_ids[key][mode],min(limit_events,len(known_pulser_ids[key][mode])))), mode, plot_map=True, hilbert=False, max_method=0, use_weight=False, mollweide=False, center_dir='E', radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90],circle_zenith=zenith_deg, circle_az=azimuth_deg, window_title='Hist ' + key, include_baselines=include_baselines,iterate_sub_baselines=iterate_sub_baselines)\n\n        if len(included_cw_sources) > 0 and plot_cw_overlap == True:\n            map_resolution = 0.25 #degrees\n            range_phi_deg = (-90, 90)\n            range_theta_deg = (0,180)\n            n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n            n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n\n            cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=1e6)\n            cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n            if mode == 'hpol':\n                cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,cor.A0_vpol,cor.A1_vpol,cor.A2_vpol,cor.A3_vpol,verbose=False)\n            else:\n                cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cor.A0_hpol,cor.A1_hpol,cor.A2_hpol,cor.A3_hpol,initial_ant0_ENU,initial_ant1_ENU,initial_ant2_ENU,initial_ant3_ENU,verbose=False)\n\n            adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=1e6)\n            adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n            if mode == 'hpol':\n                adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n            else:\n                adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])       \n\n            window_ns = 10.0\n\n            for key in included_cw_sources:\n                initial_source_distance_m = numpy.sqrt((cw_sources[key]['enu'][0] - initial_ant0_ENU[0])**2 + (cw_sources[key]['enu'][1] - initial_ant0_ENU[1])**2 + (cw_sources[key]['enu'][2] - initial_ant0_ENU[2])**2)\n                initial_azimuth_deg = numpy.rad2deg(numpy.arctan2(cw_sources[key]['enu'][1] - initial_ant0_ENU[1],cw_sources[key]['enu'][0] - initial_ant0_ENU[0]))\n                initial_zenith_deg = numpy.rad2deg(numpy.arccos((cw_sources[key]['enu'][2] - initial_ant0_ENU[2])/initial_source_distance_m))\n\n                final_source_distance_m = numpy.sqrt((cw_sources[key]['enu'][0] - ant0_ENU[0])**2 + (cw_sources[key]['enu'][1] - ant0_ENU[1])**2 + (cw_sources[key]['enu'][2] - ant0_ENU[2])**2)\n                final_azimuth_deg = numpy.rad2deg(numpy.arctan2(cw_sources[key]['enu'][1] - ant0_ENU[1],cw_sources[key]['enu'][0] - ant0_ENU[0]))\n                final_zenith_deg = numpy.rad2deg(numpy.arccos((cw_sources[key]['enu'][2] - ant0_ENU[2])/final_source_distance_m))\n\n                cor.overwriteSourceDistance(initial_source_distance_m, verbose=False, suppress_time_delay_calculations=False)\n                adjusted_cor.overwriteSourceDistance(final_source_distance_m, verbose=False, suppress_time_delay_calculations=False)\n\n                for value_mode in [overlap_value_mode]:\n                    #['distance','gaus']:\n                    mesh_azimuth_deg, mesh_elevation_deg, overlap_map, im, ax = cor.generateTimeDelayOverlapMap(mode, cw_sources[key]['time_delay_dict'], window_ns, value_mode=value_mode, plot_map=True, mollweide=False,center_dir='E',window_title='Input %s'%key, include_baselines=include_baselines)\n                    ax.axvline(initial_azimuth_deg,c='fuchsia',linewidth=1.0)\n                    ax.axhline(90.0 - initial_zenith_deg,c='fuchsia',linewidth=1.0)\n                    mesh_azimuth_deg, mesh_elevation_deg, overlap_map, im, ax = adjusted_cor.generateTimeDelayOverlapMap(mode, cw_sources[key]['time_delay_dict'], window_ns, value_mode=value_mode, plot_map=True, mollweide=False,center_dir='E',window_title='Output %s'%key, include_baselines=include_baselines)\n                    ax.axvline(final_azimuth_deg,c='fuchsia',linewidth=1.0)\n                    ax.axhline(90.0 - final_zenith_deg,c='fuchsia',linewidth=1.0)\n\n        if len(included_airplanes) > 0:\n            map_resolution = 0.5 #degrees\n            range_phi_deg = (-180, 180)\n            range_theta_deg = (0,180)\n            n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n            n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                \n            cors = [] #So animations don't reset\n            for index, key in enumerate(list(calibrated_trigtime.keys())):\n                if key not in included_airplanes:\n                    continue\n\n                run = int(key.split('-')[0])\n                reader = Reader(datapath,run)\n                eventids = known_planes[key]['eventids'][:,1]\n\n                if plot_expected_airplane_direction == False:\n                    zenith_deg = None\n                    azimuth_deg = None\n                    source_distance_m = None\n                    initial_source_distance_m = 1e6 #m\n                else:\n                    source_distance_m = numpy.sqrt(interpolated_plane_locations[key][:,0]**2 + interpolated_plane_locations[key][:,1]**2 + interpolated_plane_locations[key][:,2]**2)\n                    initial_source_distance_m = source_distance_m[0] #m\n                    azimuth_deg = numpy.rad2deg(numpy.arctan2(interpolated_plane_locations[key][:,1],interpolated_plane_locations[key][:,0]))\n                    zenith_deg = numpy.rad2deg(numpy.arccos(interpolated_plane_locations[key][:,2]/source_distance_m))\n\n                adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=initial_source_distance_m, )\n                adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                if mode == 'hpol':\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                    adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                else:\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                    adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])                    \n\n                airplane_include_baselines = numpy.where(airplane_pair_cuts[key])[0]\n\n                if plot_animated_airplane == True:\n                    adjusted_cor.animatedMap(eventids, mode, title=key + ' ' +  mode, include_baselines=airplane_include_baselines,map_source_distance_m = source_distance_m,  plane_zenith=zenith_deg,plane_az=azimuth_deg,hilbert=False, max_method=None,center_dir=known_planes[key]['dir'],save=False,dpi=300)\n                else:\n                    event_index = 0\n                    td_dict = {mode:{'[0, 1]' : [ measured_plane_time_delays[key][0][event_index]], '[0, 2]' : [measured_plane_time_delays[key][1][event_index]], '[0, 3]' : [measured_plane_time_delays[key][2][event_index]], '[1, 2]' : [measured_plane_time_delays[key][3][event_index]], '[1, 3]' : [measured_plane_time_delays[key][4][event_index]], '[2, 3]' : [measured_plane_time_delays[key][5][event_index]]}}\n                    adjusted_cor.overwriteSourceDistance(source_distance_m[event_index], verbose=False, suppress_time_delay_calculations=False)\n                    mean_corr_values, fig, ax = adjusted_cor.map(eventids[event_index], mode, include_baselines=airplane_include_baselines, plot_map=True, plot_corr=False, hilbert=False, center_dir=known_planes[key]['dir'], radius=1.0, zenith_cut_ENU=[0,90],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg[event_index], circle_az=azimuth_deg[event_index], time_delay_dict=td_dict,window_title=key)\n\n                cors.append(adjusted_cor)\n\n        print('Estimated degrees of freedom: %i'%sum([not fix_ant0_x,not fix_ant0_y,not fix_ant0_z,not fix_ant1_x,not fix_ant1_y,not fix_ant1_z,not fix_ant2_x,not fix_ant2_y,not fix_ant2_z,not fix_ant3_x,not fix_ant3_y,not fix_ant3_z,not fix_cable_delay0,not fix_cable_delay1,not fix_cable_delay2,not fix_cable_delay3]))\n        print('Estimated input measured values: %i'%(len(include_baselines)*(pulser_weight > 0)*len(included_pulsers) + len(include_baselines)*len(use_sources)))\n\n\n        print('\\n')\n        print('STARTING CONDITION INPUT VALUES HERE')\n        print('\\n')\n        print('')\n        print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%(mode, initial_ant0_x,initial_ant0_y,initial_ant0_z ,  initial_ant1_x,initial_ant1_y,initial_ant1_z,  initial_ant2_x,initial_ant2_y,initial_ant2_z,  initial_ant3_x,initial_ant3_y,initial_ant3_z))\n        print('')\n        print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%(mode,cable_delays[0],cable_delays[1],cable_delays[2],cable_delays[3]))\n\n\n\n        print('\\n')\n        print(result)\n        print('\\n')\n        print('Copy-Paste Prints:\\n------------')\n        print('')\n        print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%(mode, m.values['ant0_x'],m.values['ant0_y'],m.values['ant0_z'] ,  m.values['ant1_x'],m.values['ant1_y'],m.values['ant1_z'],  m.values['ant2_x'],m.values['ant2_y'],m.values['ant2_z'],  m.values['ant3_x'],m.values['ant3_y'],m.values['ant3_z']))\n        print('antennas_phase_%s_hesse = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%(mode, m.errors['ant0_x'],m.errors['ant0_y'],m.errors['ant0_z'] ,  m.errors['ant1_x'],m.errors['ant1_y'],m.errors['ant1_z'],  m.errors['ant2_x'],m.errors['ant2_y'],m.errors['ant2_z'],  m.errors['ant3_x'],m.errors['ant3_y'],m.errors['ant3_z']))\n        print('')\n        print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%(mode,m.values['cable_delay0'],m.values['cable_delay1'],m.values['cable_delay2'],m.values['cable_delay3']))\n        print('cable_delays_%s_hesse = numpy.array([%f,%f,%f,%f])'%(mode,m.errors['cable_delay0'],m.errors['cable_delay1'],m.errors['cable_delay2'],m.errors['cable_delay3']))\n\n        print('Code completed.')\n        print('\\a')\n\n        if True:\n            #This code is intended to save the output configuration produced by this script. \n            initial_deploy_index = str(info.returnDefaultDeploy())\n            initial_origin, initial_antennas_physical, initial_antennas_phase_hpol, initial_antennas_phase_vpol, initial_cable_delays, initial_description = bcr.configReader(initial_deploy_index,return_description=True)\n\n            output_origin = initial_origin\n            output_antennas_physical = initial_antennas_physical\n            if mode == 'hpol':\n                output_antennas_phase_hpol = output_antennas_phase\n                output_antennas_phase_vpol = initial_antennas_phase_vpol\n            else:\n                output_antennas_phase_hpol = initial_antennas_phase_hpol\n                output_antennas_phase_vpol = output_antennas_phase\n            output_cable_delays = initial_cable_delays\n            output_cable_delays[mode] = resulting_cable_delays\n            output_description = 'Automatically generated description for a calibration starting from deploy_index: %s.  This config has updated %s values based on a calibration that was performed.  Initial description: %s'%(initial_deploy_index, mode, initial_description)\n\n            if len(os.path.split(initial_deploy_index)) == 2:\n                json_path = initial_deploy_index\n            else:\n                json_path = os.path.join(os.environ['BEACON_ANALYSIS_DIR'],'config','automatically_generated_config_0.json')\n            \n            with open('./find_phase_centers_from_RFI.py', \"r\") as this_file:\n                #read whole file to a string\n                script_string = this_file.read()\n\n            bcr.configWriter(json_path, output_origin, output_antennas_physical, output_antennas_phase_hpol, output_antennas_phase_vpol, output_cable_delays, description=output_description,update_latlonel=True,force_write=True, additional_text=script_string) #does not overwrite.\n\n\n\n            \n    except Exception as e:\n        print('Error in main loop.')\n        print(e)\n        exc_type, exc_obj, exc_tb = sys.exc_info()\n        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n        print(exc_type, fname, exc_tb.tb_lineno)\n\n\n\n\n\n\n",
    "origin": {
        "latlonel": [
            37.58933883,
            -118.23762017,
            3850.8272
        ]
    },
    "antennas": {
        "ant0": {
            "physical": {
                "latlonel": [
                    37.58933883,
                    -118.23762017,
                    3850.8272
                ],
                "enu": [
                    0.0,
                    0.0,
                    0.0
                ]
            },
            "hpol": {
                "latlonel": [
                    37.58933883,
                    -118.23762017,
                    3850.8272
                ],
                "enu": [
                    0.0,
                    0.0,
                    0.0
                ],
                "cable_delay": 423.37836156,
                "channel": 0
            },
            "vpol": {
                "latlonel": [
                    37.58933883,
                    -118.23762017,
                    3850.8272
                ],
                "enu": [
                    0.0,
                    0.0,
                    0.0
                ],
                "cable_delay": 428.59277751,
                "channel": 1
            }
        },
        "ant1": {
            "physical": {
                "latlonel": [
                    37.58922017,
                    -118.238006,
                    3864.9272
                ],
                "enu": [
                    -34.09717765940225,
                    -13.177855670376632,
                    14.099895383040028
                ]
            },
            "hpol": {
                "latlonel": [
                    37.58922473,
                    -118.23801731,
                    3865.91193836
                ],
                "enu": [
                    -35.096686096328206,
                    -12.671437312184915,
                    15.084629359435024
                ],
                "cable_delay": 433.05998688349376,
                "channel": 2
            },
            "vpol": {
                "latlonel": [
                    37.58921797,
                    -118.23801506,
                    3865.92715482
                ],
                "enu": [
                    -34.89816185369531,
                    -13.421816611461914,
                    15.099845369866392
                ],
                "cable_delay": 432.14278613737616,
                "channel": 3
            }
        },
        "ant2": {
            "physical": {
                "latlonel": [
                    37.58889767,
                    -118.2377077,
                    3854.5272
                ],
                "enu": [
                    -7.735360080868686,
                    -48.99345704634992,
                    3.6998067012522853
                ]
            },
            "hpol": {
                "latlonel": [
                    37.58888511,
                    -118.23769639,
                    3853.53309565
                ],
                "enu": [
                    -6.735852310001947,
                    -50.38831322870463,
                    2.705692589960833
                ],
                "cable_delay": 414.4834653383668,
                "channel": 4
            },
            "vpol": {
                "latlonel": [
                    37.58888891,
                    -118.23771046,
                    3854.04811696
                ],
                "enu": [
                    -7.979157804463211,
                    -49.9661846519524,
                    3.2207157971832148
                ],
                "cable_delay": 423.4099358397286,
                "channel": 5
            }
        },
        "ant3": {
            "physical": {
                "latlonel": [
                    37.588943,
                    -118.23796283,
                    3864.6272
                ],
                "enu": [
                    -30.282201162166317,
                    -43.95930732188664,
                    13.799776398332899
                ]
            },
            "hpol": {
                "latlonel": [
                    37.58894563,
                    -118.23796354,
                    3865.62469792
                ],
                "enu": [
                    -30.34495030195434,
                    -43.667236229111666,
                    14.79727603166197
                ],
                "cable_delay": 424.12431030752305,
                "channel": 6
            },
            "vpol": {
                "latlonel": [
                    37.58893696,
                    -118.23796865,
                    3864.2416771
                ],
                "enu": [
                    -30.79665030067085,
                    -44.63049092628287,
                    13.414246367609739
                ],
                "cable_delay": 423.6234166682837,
                "channel": 7
            }
        }
    }
}