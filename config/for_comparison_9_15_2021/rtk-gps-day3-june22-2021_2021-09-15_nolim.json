{
    "description": "This starts from rtk-gps-day3-june22-2021.json and allowed for antennas 1,2,3 and their cable lengths to vary in a chi squared minimization performed per polarization using the 6 pulsing sites and the time delays obtained from them.",
    "additional_text": "'''\nGiven the best measured time delays for each of the 6 pulsing sites from the July 2021 BEACON pulsing campaign, this\nwill attempt to minimize the antenna positions and cable delays.  \n'''\n\n#General Imports\nimport numpy\nimport itertools\nimport os\nimport sys\nimport csv\nimport scipy\nimport scipy.interpolate\nimport pymap3d as pm\nfrom iminuit import Minuit\nimport inspect\nimport h5py\n\n#Personal Imports\nfrom beaconroot.examples.beacon_data_reader import Reader #Must be imported before matplotlib or else plots don't load.\nfrom beacon.tools.data_handler import createFile, getTimes\nimport beacon.tools.station as bc\nimport beacon.tools.info as info\nimport beacon.tools.get_plane_tracks as pt\nfrom beacon.tools.fftmath import TimeDelayCalculator\nfrom beacon.tools.data_slicer import dataSlicerSingleRun\nfrom beacon.tools.correlator import Correlator\nimport beacon.tools.config_reader as bcr\n\n\n#Plotting Imports\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom beacon.analysis.aug2021.parse_pulsing_runs import PulserInfo, predictAlignment\n\n\n#Settings\nfrom pprint import pprint\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nplt.ion()\ndatapath = os.environ['BEACON_DATA']\n\nn = 1.0003 #Index of refraction of air  #Should use https://www.itu.int/dms_pubrec/itu-r/rec/p/R-REC-P.453-11-201507-S!!PDF-E.pdf \nc = 299792458/n #m/s\n\n\nmeasured_time_delays = {}\n\nmeasured_time_delays['d2sa'] = {}\n\nmeasured_time_delays['d2sa']['hpol'] = {}\nmeasured_time_delays['d2sa']['hpol']['delays_ns'] = numpy.array([-63.14130048,  99.38889723,  15.64368973, 162.3543261 ,  78.65923556, -83.85536426])\nmeasured_time_delays['d2sa']['hpol']['sigma_ns'] = numpy.array([0.17644782, 0.1987261 , 0.1869557 , 0.17651783, 0.20839108, 0.16655057])\n\nmeasured_time_delays['d2sa']['vpol'] = {}\nmeasured_time_delays['d2sa']['vpol']['delays_ns'] = numpy.array([-70.02166451,  86.85031485,  11.30731964, 156.85079363,  81.30439472, -75.52956864])\nmeasured_time_delays['d2sa']['vpol']['sigma_ns'] = numpy.array([0.11617623, 0.10046536, 0.14437393, 0.12835038, 0.13399128, 0.11643392])\n\n\nmeasured_time_delays['d3sa'] = {}\n\nmeasured_time_delays['d3sa']['hpol'] = {}\nmeasured_time_delays['d3sa']['hpol']['delays_ns'] = numpy.array([-100.9643034 ,   39.12872542,  -52.79778144,  140.02931026,  48.10385574,  -92.04129368])\nmeasured_time_delays['d3sa']['hpol']['sigma_ns'] = numpy.array([0.06557082, 0.07901542, 0.05177623, 0.07434778, 0.05871251, 0.06644926])\n\nmeasured_time_delays['d3sa']['vpol'] = {}\nmeasured_time_delays['d3sa']['vpol']['delays_ns'] = numpy.array([-107.24171021,   26.75577314,  -56.59551099,  134.310878  ,  50.92560667,  -83.4251287 ])\nmeasured_time_delays['d3sa']['vpol']['sigma_ns'] = numpy.array([0.00387661, 0.11545836, 0.16632272, 0.14901272, 0.26207502, 0.18229291])\n\n\nmeasured_time_delays['d3sb'] = {}\n\nmeasured_time_delays['d3sb']['hpol'] = {}\nmeasured_time_delays['d3sb']['hpol']['delays_ns'] = numpy.array([-118.24860437,    3.11211276,  -89.96367379,  121.1021402 ,  28.22563402,  -93.03585489])\nmeasured_time_delays['d3sb']['hpol']['sigma_ns'] = numpy.array([0.07043019, 0.07144881, 0.11915923, 0.06628051, 0.11001272, 0.11761661])\n\nmeasured_time_delays['d3sb']['vpol'] = {}\nmeasured_time_delays['d3sb']['vpol']['delays_ns'] = numpy.array([-124.30123945,   -9.2209266 ,  -93.83340383,  115.03118086,  30.68261666,  -84.49031588])\nmeasured_time_delays['d3sb']['vpol']['sigma_ns'] = numpy.array([0.19245565, 0.25414605, 0.31903936, 0.29155481, 0.37501811, 0.37506079])\n\n\nmeasured_time_delays['d3sc'] = {}\n\nmeasured_time_delays['d3sc']['hpol'] = {}\n# measured_time_delays['d3sc']['hpol']['delays_ns'] = numpy.array([-124.50656734,  -12.67950929, -105.88945604,  111.74108185,  18.69346089,  -93.14504255])\n# measured_time_delays['d3sc']['hpol']['sigma_ns'] = numpy.array([0.09842963, 0.10768558, 0.09280989, 0.07931319, 0.10520202, 0.11498814])\nmeasured_time_delays['d3sc']['hpol']['delays_ns'] = numpy.array([-124.91391579,  -13.15003191, -105.93984956,  111.70737811, 19.02486885,  -92.80343433])\nmeasured_time_delays['d3sc']['hpol']['sigma_ns'] = numpy.array([0.22920522, 0.19421038, 0.21978905, 0.14111465, 0.21970912, 0.24054242])\n\nmeasured_time_delays['d3sc']['vpol'] = {}\nmeasured_time_delays['d3sc']['vpol']['delays_ns'] = numpy.array([-131.23459943,  -25.33789367, -109.8755877 ,  105.97147853,  21.44267034,  -84.53585933])\nmeasured_time_delays['d3sc']['vpol']['sigma_ns'] = numpy.array([0.09881008, 0.13022104, 0.13173773, 0.12295037, 0.13130819, 0.12364438])\n\n\nmeasured_time_delays['d4sa'] = {}\n\nmeasured_time_delays['d4sa']['hpol'] = {}\nmeasured_time_delays['d4sa']['hpol']['delays_ns'] = numpy.array([-131.05787774,  -80.48935891, -156.11747805,   50.37710341, -25.22189312,  -75.68285714])\nmeasured_time_delays['d4sa']['hpol']['sigma_ns'] = numpy.array([0.11962765, 0.13788958, 0.22954265, 0.13345461, 0.22534428, 0.28682674])\n\nmeasured_time_delays['d4sa']['vpol'] = {}\nmeasured_time_delays['d4sa']['vpol']['delays_ns'] = numpy.array([-137.63837021,  -93.07503106, -160.44372872,   44.55829189, -22.84918766,  -67.41484311])\nmeasured_time_delays['d4sa']['vpol']['sigma_ns'] = numpy.array([0.19247366, 0.09339184, 0.22085245, 0.19228158, 0.23594743, 0.22635479])\n\n\nmeasured_time_delays['d4sb'] = {}\n# Hpol 4-6 was done using a windowed signal because it had a weird cross corr that seemed to be a cycle off of the expected delay. \nmeasured_time_delays['d4sb']['hpol'] = {}\nmeasured_time_delays['d4sb']['hpol']['delays_ns'] = numpy.array([-108.48271003, -145.52936836, -182.42420984,  -37.07392944, -74.3088871 ,  -36.91059479])\nmeasured_time_delays['d4sb']['hpol']['sigma_ns'] = numpy.array([0.14458919, 0.12773987, 0.23587384, 0.10636644, 0.28704927, 0.17559892])\n\n\nmeasured_time_delays['d4sb']['vpol'] = {}\nmeasured_time_delays['d4sb']['vpol']['delays_ns'] = numpy.array([-115.07169322, -157.99423434, -186.63177201,  -43.00198129, -71.51992424,  -28.60474262])\nmeasured_time_delays['d4sb']['vpol']['sigma_ns'] = numpy.array([0.17114803, 0.16868515, 0.21001127, 0.23489705, 0.157785  , 0.3050704 ])\n\n#The attenuations used to get the time delays\nattenuations_dict = {'hpol':{           'd2sa' : [20],\n                                        'd3sa' : [10],\n                                        'd3sb' : [6],\n                                        'd3sc' : [10],\n                                        'd4sa' : [20],\n                                        'd4sb' : [6]\n                                    },\n                             'vpol':{   'd2sa' : [10],\n                                        'd3sa' : [6],\n                                        'd3sb' : [20],\n                                        'd3sc' : [10],\n                                        'd4sa' : [10],\n                                        'd4sb' : [6]\n                                    }\n                            }\n\n\nclass AntennaMinimizer:\n    '''\n    This is the minimizer to be used for a single polarization.  It is intended to readily encapsulate all of the\n    necessary prepwork for a single pol, such that the 2 could be readily combined easily into a single minimization.\n\n    This doesn't actually include the minimizer itself, but rather the meta data for the chi^2 function that will\n    be minimized.  How that function is handled is still done externally.\n    '''\n    def __init__(self, pol, deploy_index, origin=None, use_sites=['d2sa','d3sa','d3sb','d3sc','d4sa','d4sb'], \n                    random_offset_amount=0.05,\n                    included_antennas_lumped=[0,1,2,3],\n                    include_baselines=[0,1,2,3,4,5],\n                    initial_step_x=0.1,\n                    initial_step_y=0.1,\n                    initial_step_z=0.1,\n                    initial_step_cable_delay=3,\n                    cable_delay_guess_range=30,\n                    antenna_position_guess_range_x=0.75,\n                    antenna_position_guess_range_y=0.75,\n                    antenna_position_guess_range_z=0.75,\n                    manual_offset_ant0_x=0,\n                    manual_offset_ant0_y=0,\n                    manual_offset_ant0_z=0,\n                    manual_offset_ant1_x=0,\n                    manual_offset_ant1_y=0,\n                    manual_offset_ant1_z=0,\n                    manual_offset_ant2_x=0,\n                    manual_offset_ant2_y=0,\n                    manual_offset_ant2_z=0,\n                    manual_offset_ant3_x=0,\n                    manual_offset_ant3_y=0,\n                    manual_offset_ant3_z=0,\n                    fix_ant0_x=True,\n                    fix_ant0_y=True,\n                    fix_ant0_z=True,\n                    fix_ant1_x=False,\n                    fix_ant1_y=False,\n                    fix_ant1_z=False,\n                    fix_ant2_x=False,\n                    fix_ant2_y=False,\n                    fix_ant2_z=False,\n                    fix_ant3_x=False,\n                    fix_ant3_y=False,\n                    fix_ant3_z=False,\n                    fix_cable_delay0=True,\n                    fix_cable_delay1=False,\n                    fix_cable_delay2=False,\n                    fix_cable_delay3=False):\n        try:\n            self.included_antennas_lumped = included_antennas_lumped\n            self.include_baselines = include_baselines\n            self.included_antennas_channels = numpy.concatenate([[2*i,2*i+1] for i in self.included_antennas_lumped])\n            self.deploy_index = deploy_index\n            self.pol = pol\n            self.use_sites = use_sites\n\n\n            #Force antennas not to be included to be fixed.  \n            if not(0 in self.included_antennas_lumped):\n                fix_ant0_x = True\n                fix_ant0_y = True\n                fix_ant0_z = True\n                fix_cable_delay0 = True\n\n            if not(1 in self.included_antennas_lumped):\n                fix_ant1_x = True\n                fix_ant1_y = True\n                fix_ant1_z = True\n                fix_cable_delay1 = True\n            if not(2 in self.included_antennas_lumped):\n                fix_ant2_x = True\n                fix_ant2_y = True\n                fix_ant2_z = True\n                fix_cable_delay2 = True\n            if not(3 in self.included_antennas_lumped):\n                fix_ant3_x = True\n                fix_ant3_y = True\n                fix_ant3_z = True\n                fix_cable_delay3 = True\n\n            #This math is to set the pairs to include in the calculation.  Typically it will be all of them, but if the option is enabled to remove some\n            #from the calculation then this will allow for that to be done.\n            self.pairs = numpy.array(list(itertools.combinations((0,1,2,3), 2)))\n            self.pairs_cut = []\n            for pair_index, pair in enumerate(numpy.array(list(itertools.combinations((0,1,2,3), 2)))):\n                self.pairs_cut.append(numpy.logical_and(numpy.all(numpy.isin(numpy.array(pair),self.included_antennas_lumped)), pair_index in self.include_baselines)) #include_baselines Overwritten when antennas removed.\n            self.include_baselines = numpy.where(self.pairs_cut)[0] #Effectively the same as the self.pairs_cut but index based for baselines.\n            #include_baselines = numpy.arange(4)\n            print('Including baseline self.pairs:')\n            print(self.pairs[self.pairs_cut])\n\n            #I think adding an absolute time offset for each antenna and letting that vary could be interesting.  It could be used to adjust the cable delays.\n            self.cable_delays = info.loadCableDelays(deploy_index=self.deploy_index,return_raw=True)[self.pol]\n\n            if origin is None:\n                self.origin = info.loadAntennaZeroLocation(deploy_index=self.deploy_index)\n            else:\n                self.origin = origin\n\n            antennas_physical, antennas_phase_hpol, antennas_phase_vpol = info.loadAntennaLocationsENU(deploy_index=self.deploy_index)\n\n            pulser_info = PulserInfo()\n\n            self.pulser_locations_ENU = {}\n\n            for site in self.use_sites:        \n                #Prepare correlators for future use on a per event basis\n                source_latlonel = pulser_info.getPulserLatLonEl(site)\n                \n                # Prepare expected angle and arrival times\n                self.pulser_locations_ENU[site] = pm.geodetic2enu(source_latlonel[0],source_latlonel[1],source_latlonel[2],self.origin[0],self.origin[1],self.origin[2])\n\n\n            if True:\n                if self.pol == 'hpol':\n                    self.antennas_phase_start = antennas_phase_hpol\n                else:\n                    self.antennas_phase_start = antennas_phase_vpol\n            else:\n                print('WARNING, USING PHYSICAL LOCATIONS TO START')\n                self.antennas_phase_start = antennas_physical\n\n            if cable_delay_guess_range is not None:\n\n                limit_cable_delay0 = (self.cable_delays[0] - cable_delay_guess_range , self.cable_delays[0] + cable_delay_guess_range)\n                limit_cable_delay1 = (self.cable_delays[1] - cable_delay_guess_range , self.cable_delays[1] + cable_delay_guess_range)\n                limit_cable_delay2 = (self.cable_delays[2] - cable_delay_guess_range , self.cable_delays[2] + cable_delay_guess_range)\n                limit_cable_delay3 = (self.cable_delays[3] - cable_delay_guess_range , self.cable_delays[3] + cable_delay_guess_range)\n            else:\n                limit_cable_delay0 = None\n                limit_cable_delay1 = None\n                limit_cable_delay2 = None\n                limit_cable_delay3 = None\n\n            if antenna_position_guess_range_x is not None:\n                ant0_physical_limits_x = (self.antennas_phase_start[0][0] + manual_offset_ant0_x - antenna_position_guess_range_x ,self.antennas_phase_start[0][0] + manual_offset_ant0_x + antenna_position_guess_range_x)\n                ant1_physical_limits_x = (self.antennas_phase_start[1][0] + manual_offset_ant1_x - antenna_position_guess_range_x ,self.antennas_phase_start[1][0] + manual_offset_ant1_x + antenna_position_guess_range_x)\n                ant2_physical_limits_x = (self.antennas_phase_start[2][0] + manual_offset_ant2_x - antenna_position_guess_range_x ,self.antennas_phase_start[2][0] + manual_offset_ant2_x + antenna_position_guess_range_x)\n                ant3_physical_limits_x = (self.antennas_phase_start[3][0] + manual_offset_ant3_x - antenna_position_guess_range_x ,self.antennas_phase_start[3][0] + manual_offset_ant3_x + antenna_position_guess_range_x)\n            else:\n                ant0_physical_limits_x = None\n                ant1_physical_limits_x = None\n                ant2_physical_limits_x = None\n                ant3_physical_limits_x = None\n\n            if antenna_position_guess_range_y is not None:\n                ant0_physical_limits_y = (self.antennas_phase_start[0][1] + manual_offset_ant0_y - antenna_position_guess_range_y ,self.antennas_phase_start[0][1] + manual_offset_ant0_y + antenna_position_guess_range_y)\n                ant1_physical_limits_y = (self.antennas_phase_start[1][1] + manual_offset_ant1_y - antenna_position_guess_range_y ,self.antennas_phase_start[1][1] + manual_offset_ant1_y + antenna_position_guess_range_y)\n                ant2_physical_limits_y = (self.antennas_phase_start[2][1] + manual_offset_ant2_y - antenna_position_guess_range_y ,self.antennas_phase_start[2][1] + manual_offset_ant2_y + antenna_position_guess_range_y)\n                ant3_physical_limits_y = (self.antennas_phase_start[3][1] + manual_offset_ant3_y - antenna_position_guess_range_y ,self.antennas_phase_start[3][1] + manual_offset_ant3_y + antenna_position_guess_range_y)\n            else:\n                ant0_physical_limits_y = None\n                ant1_physical_limits_y = None\n                ant2_physical_limits_y = None\n                ant3_physical_limits_y = None\n\n            if antenna_position_guess_range_z is not None:\n                ant0_physical_limits_z = (self.antennas_phase_start[0][2] + manual_offset_ant0_z - antenna_position_guess_range_z ,self.antennas_phase_start[0][2] + manual_offset_ant0_z + antenna_position_guess_range_z)\n                ant1_physical_limits_z = (self.antennas_phase_start[1][2] + manual_offset_ant1_z - antenna_position_guess_range_z ,self.antennas_phase_start[1][2] + manual_offset_ant1_z + antenna_position_guess_range_z)\n                ant2_physical_limits_z = (self.antennas_phase_start[2][2] + manual_offset_ant2_z - antenna_position_guess_range_z ,self.antennas_phase_start[2][2] + manual_offset_ant2_z + antenna_position_guess_range_z)\n                ant3_physical_limits_z = (self.antennas_phase_start[3][2] + manual_offset_ant3_z - antenna_position_guess_range_z ,self.antennas_phase_start[3][2] + manual_offset_ant3_z + antenna_position_guess_range_z)\n            else:\n                ant0_physical_limits_z = None\n                ant1_physical_limits_z = None\n                ant2_physical_limits_z = None\n                ant3_physical_limits_z = None\n\n            if random_offset_amount > 0:\n                print('RANDOMLY SHIFTING INPUT POSITIONS BY SPECIFIED AMOUNT:%0.2f m'%random_offset_amount)\n\n            initial_ant0_x = manual_offset_ant0_x + self.antennas_phase_start[0][0] + float(not fix_ant0_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant0_y = manual_offset_ant0_y + self.antennas_phase_start[0][1] + float(not fix_ant0_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant0_z = manual_offset_ant0_z + self.antennas_phase_start[0][2] + float(not fix_ant0_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant1_x = manual_offset_ant1_x + self.antennas_phase_start[1][0] + float(not fix_ant1_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant1_y = manual_offset_ant1_y + self.antennas_phase_start[1][1] + float(not fix_ant1_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant1_z = manual_offset_ant1_z + self.antennas_phase_start[1][2] + float(not fix_ant1_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant2_x = manual_offset_ant2_x + self.antennas_phase_start[2][0] + float(not fix_ant2_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant2_y = manual_offset_ant2_y + self.antennas_phase_start[2][1] + float(not fix_ant2_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant2_z = manual_offset_ant2_z + self.antennas_phase_start[2][2] + float(not fix_ant2_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant3_x = manual_offset_ant3_x + self.antennas_phase_start[3][0] + float(not fix_ant3_x)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant3_y = manual_offset_ant3_y + self.antennas_phase_start[3][1] + float(not fix_ant3_y)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n            initial_ant3_z = manual_offset_ant3_z + self.antennas_phase_start[3][2] + float(not fix_ant3_z)*numpy.random.uniform(low=-random_offset_amount, high=random_offset_amount,size=1)[0]\n\n            self.initial_ant0_ENU = numpy.array([initial_ant0_x, initial_ant0_y, initial_ant0_z])\n            self.initial_ant1_ENU = numpy.array([initial_ant1_x, initial_ant1_y, initial_ant1_z])\n            self.initial_ant2_ENU = numpy.array([initial_ant2_x, initial_ant2_y, initial_ant2_z])\n            self.initial_ant3_ENU = numpy.array([initial_ant3_x, initial_ant3_y, initial_ant3_z])\n\n            if True:\n                #Initial baselines just to be printed out\n                initial_baselines = {   '01':numpy.sqrt((initial_ant0_x - initial_ant1_x)**2 + (initial_ant0_y - initial_ant1_y)**2 + (initial_ant0_z - initial_ant1_z)**2),\\\n                                        '02':numpy.sqrt((initial_ant0_x - initial_ant2_x)**2 + (initial_ant0_y - initial_ant2_y)**2 + (initial_ant0_z - initial_ant2_z)**2),\\\n                                        '03':numpy.sqrt((initial_ant0_x - initial_ant3_x)**2 + (initial_ant0_y - initial_ant3_y)**2 + (initial_ant0_z - initial_ant3_z)**2),\\\n                                        '12':numpy.sqrt((initial_ant1_x - initial_ant2_x)**2 + (initial_ant1_y - initial_ant2_y)**2 + (initial_ant1_z - initial_ant2_z)**2),\\\n                                        '13':numpy.sqrt((initial_ant1_x - initial_ant3_x)**2 + (initial_ant1_y - initial_ant3_y)**2 + (initial_ant1_z - initial_ant3_z)**2),\\\n                                        '23':numpy.sqrt((initial_ant2_x - initial_ant3_x)**2 + (initial_ant2_y - initial_ant3_y)**2 + (initial_ant2_z - initial_ant3_z)**2)}\n                print(self.pol)\n                print('The initial baselines (specified by deploy_index = %s) with random offsets and manual adjustsments in meters are:'%(str(info.returnDefaultDeploy())))\n                print(initial_baselines)\n\n                for key in self.use_sites:\n                    d0 = numpy.sqrt((self.pulser_locations_ENU[key][0] - initial_ant0_x)**2 + (self.pulser_locations_ENU[key][1] - initial_ant0_y)**2 + (self.pulser_locations_ENU[key][2] - initial_ant0_z)**2 ) #m\n                    print('Pulser %s is %0.2f m away from Antenna 0'%(key, d0))\n\n\n            self.initial_ant0_x=initial_ant0_x\n            self.initial_ant0_y=initial_ant0_y\n            self.initial_ant0_z=initial_ant0_z\n            self.initial_ant1_x=initial_ant1_x\n            self.initial_ant1_y=initial_ant1_y\n            self.initial_ant1_z=initial_ant1_z\n            self.initial_ant2_x=initial_ant2_x\n            self.initial_ant2_y=initial_ant2_y\n            self.initial_ant2_z=initial_ant2_z\n            self.initial_ant3_x=initial_ant3_x\n            self.initial_ant3_y=initial_ant3_y\n            self.initial_ant3_z=initial_ant3_z\n            self.cable_delay0=self.cable_delays[0]\n            self.cable_delay1=self.cable_delays[1]\n            self.cable_delay2=self.cable_delays[2]\n            self.cable_delay3=self.cable_delays[3]\n\n            self.errors = {}\n            self.limits = {}\n            self.fixed = {}\n            self.errors['ant0_x'] = initial_step_x\n            self.errors['ant0_y'] = initial_step_y\n            self.errors['ant0_z'] = initial_step_z\n            self.errors['ant1_x'] = initial_step_x\n            self.errors['ant1_y'] = initial_step_y\n            self.errors['ant1_z'] = initial_step_z\n            self.errors['ant2_x'] = initial_step_x\n            self.errors['ant2_y'] = initial_step_y\n            self.errors['ant2_z'] = initial_step_z\n            self.errors['ant3_x'] = initial_step_x\n            self.errors['ant3_y'] = initial_step_y\n            self.errors['ant3_z'] = initial_step_z\n            self.errors['cable_delay0'] = initial_step_cable_delay\n            self.errors['cable_delay1'] = initial_step_cable_delay\n            self.errors['cable_delay2'] = initial_step_cable_delay\n            self.errors['cable_delay3'] = initial_step_cable_delay\n            self.errordef = 1.0\n            self.limits['ant0_x'] = ant0_physical_limits_x\n            self.limits['ant0_y'] = ant0_physical_limits_y\n            self.limits['ant0_z'] = ant0_physical_limits_z\n            self.limits['ant1_x'] = ant1_physical_limits_x\n            self.limits['ant1_y'] = ant1_physical_limits_y\n            self.limits['ant1_z'] = ant1_physical_limits_z\n            self.limits['ant2_x'] = ant2_physical_limits_x\n            self.limits['ant2_y'] = ant2_physical_limits_y\n            self.limits['ant2_z'] = ant2_physical_limits_z\n            self.limits['ant3_x'] = ant3_physical_limits_x\n            self.limits['ant3_y'] = ant3_physical_limits_y\n            self.limits['ant3_z'] = ant3_physical_limits_z\n            self.limits['cable_delay0'] = limit_cable_delay0\n            self.limits['cable_delay1'] = limit_cable_delay1\n            self.limits['cable_delay2'] = limit_cable_delay2\n            self.limits['cable_delay3'] = limit_cable_delay3\n            self.fixed['ant0_x'] = fix_ant0_x\n            self.fixed['ant0_y'] = fix_ant0_y\n            self.fixed['ant0_z'] = fix_ant0_z\n            self.fixed['ant1_x'] = fix_ant1_x\n            self.fixed['ant1_y'] = fix_ant1_y\n            self.fixed['ant1_z'] = fix_ant1_z\n            self.fixed['ant2_x'] = fix_ant2_x\n            self.fixed['ant2_y'] = fix_ant2_y\n            self.fixed['ant2_z'] = fix_ant2_z\n            self.fixed['ant3_x'] = fix_ant3_x\n            self.fixed['ant3_y'] = fix_ant3_y\n            self.fixed['ant3_z'] = fix_ant3_z\n            self.fixed['cable_delay0'] = fix_cable_delay0\n            self.fixed['cable_delay1'] = fix_cable_delay1\n            self.fixed['cable_delay2'] = fix_cable_delay2\n            self.fixed['cable_delay3'] = fix_cable_delay3\n        except Exception as e:\n            print('\\nError in %s'%inspect.stack()[0][3])\n            print(e)\n            exc_type, exc_obj, exc_tb = sys.exc_info()\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n            print(exc_type, fname, exc_tb.tb_lineno)\n\n    def rawChi2(self, ant0_x, ant0_y, ant0_z, ant1_x, ant1_y, ant1_z, ant2_x, ant2_y, ant2_z, ant3_x, ant3_y, ant3_z, cable_delay0, cable_delay1, cable_delay2, cable_delay3):\n        '''\n        This is a chi^2 that loops over locations from potential RFI, calculating expected time delays for those locations.  Then\n        it will compares those to the calculated time delays for suspected corresponding events.  \n        '''\n        try:\n            #Calculate distances (already converted to ns) from pulser to each antenna\n            chi_2 = 0.0\n            _cable_delays = [cable_delay0,cable_delay1,cable_delay2,cable_delay3]\n\n            for key in self.use_sites:\n                d0 = (numpy.sqrt((self.pulser_locations_ENU[key][0] - ant0_x)**2 + (self.pulser_locations_ENU[key][1] - ant0_y)**2 + (self.pulser_locations_ENU[key][2] - ant0_z)**2 )/c)*1.0e9 #ns\n                d1 = (numpy.sqrt((self.pulser_locations_ENU[key][0] - ant1_x)**2 + (self.pulser_locations_ENU[key][1] - ant1_y)**2 + (self.pulser_locations_ENU[key][2] - ant1_z)**2 )/c)*1.0e9 #ns\n                d2 = (numpy.sqrt((self.pulser_locations_ENU[key][0] - ant2_x)**2 + (self.pulser_locations_ENU[key][1] - ant2_y)**2 + (self.pulser_locations_ENU[key][2] - ant2_z)**2 )/c)*1.0e9 #ns\n                d3 = (numpy.sqrt((self.pulser_locations_ENU[key][0] - ant3_x)**2 + (self.pulser_locations_ENU[key][1] - ant3_y)**2 + (self.pulser_locations_ENU[key][2] - ant3_z)**2 )/c)*1.0e9 #ns\n\n                d = [d0,d1,d2,d3]\n\n                for pair_index, pair in enumerate(self.pairs):\n                    if self.pairs_cut[pair_index]:\n                        geometric_time_delay = (d[pair[0]] + _cable_delays[pair[0]]) - (d[pair[1]] + _cable_delays[pair[1]])\n                        vals = ((geometric_time_delay - measured_time_delays[key][self.pol]['delays_ns'][pair_index])**2)/(measured_time_delays[key][self.pol]['sigma_ns'][pair_index]**2)\n                        chi_2 += numpy.sum(vals)\n\n            return chi_2\n        except Exception as e:\n            print('Error in rawChi2')\n            print(e)\n            exc_type, exc_obj, exc_tb = sys.exc_info()\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n            print(exc_type, fname, exc_tb.tb_lineno)\n\n\nclass CombinedAntennaMinimizer:\n    '''\n    Takes 2 AntennaMinimizer objects (of different polarizations) and defines a new chi^2 that combines their info.\n    '''\n    def __init__(self, am_hpol, am_vpol):\n        self.am_hpol = am_hpol\n        self.am_vpol = am_vpol\n\n    def rawChi2(self, ant0_x_hpol, ant0_y_hpol, ant0_z_hpol, ant1_x_hpol, ant1_y_hpol, ant1_z_hpol, ant2_x_hpol, ant2_y_hpol, ant2_z_hpol, ant3_x_hpol, ant3_y_hpol, ant3_z_hpol, cable_delay0_hpol, cable_delay1_hpol, cable_delay2_hpol, cable_delay3_hpol, cable_delay0_vpol, cable_delay1_vpol, cable_delay2_vpol, cable_delay3_vpol):\n        '''\n        This will use the hpol variations to also move about the vpol antennas (such that they move with the same offset\n        from the original value).  The combined chi^2 is returned.\n        '''\n        try:\n            ant0_x_hpol_offset = ant0_x_hpol -  self.am_hpol.initial_ant0_x\n            ant0_y_hpol_offset = ant0_y_hpol -  self.am_hpol.initial_ant0_y\n            ant0_z_hpol_offset = ant0_z_hpol -  self.am_hpol.initial_ant0_z\n            ant1_x_hpol_offset = ant1_x_hpol -  self.am_hpol.initial_ant1_x\n            ant1_y_hpol_offset = ant1_y_hpol -  self.am_hpol.initial_ant1_y\n            ant1_z_hpol_offset = ant1_z_hpol -  self.am_hpol.initial_ant1_z\n            ant2_x_hpol_offset = ant2_x_hpol -  self.am_hpol.initial_ant2_x\n            ant2_y_hpol_offset = ant2_y_hpol -  self.am_hpol.initial_ant2_y\n            ant2_z_hpol_offset = ant2_z_hpol -  self.am_hpol.initial_ant2_z\n            ant3_x_hpol_offset = ant3_x_hpol -  self.am_hpol.initial_ant3_x\n            ant3_y_hpol_offset = ant3_y_hpol -  self.am_hpol.initial_ant3_y\n            ant3_z_hpol_offset = ant3_z_hpol -  self.am_hpol.initial_ant3_z\n\n\n            chi_2_hpol = self.am_hpol.rawChi2(  ant0_x_hpol_offset + self.am_hpol.initial_ant0_x,\n                                                ant0_y_hpol_offset + self.am_hpol.initial_ant0_y,\n                                                ant0_z_hpol_offset + self.am_hpol.initial_ant0_z,\n                                                ant1_x_hpol_offset + self.am_hpol.initial_ant1_x,\n                                                ant1_y_hpol_offset + self.am_hpol.initial_ant1_y,\n                                                ant1_z_hpol_offset + self.am_hpol.initial_ant1_z,\n                                                ant2_x_hpol_offset + self.am_hpol.initial_ant2_x,\n                                                ant2_y_hpol_offset + self.am_hpol.initial_ant2_y,\n                                                ant2_z_hpol_offset + self.am_hpol.initial_ant2_z,\n                                                ant3_x_hpol_offset + self.am_hpol.initial_ant3_x,\n                                                ant3_y_hpol_offset + self.am_hpol.initial_ant3_y,\n                                                ant3_z_hpol_offset + self.am_hpol.initial_ant3_z,\n                                                cable_delay0_hpol,\n                                                cable_delay1_hpol,\n                                                cable_delay2_hpol,\n                                                cable_delay3_hpol)\n            chi_2_vpol = self.am_vpol.rawChi2(  ant0_x_hpol_offset + self.am_vpol.initial_ant0_x,\n                                                ant0_y_hpol_offset + self.am_vpol.initial_ant0_y,\n                                                ant0_z_hpol_offset + self.am_vpol.initial_ant0_z,\n                                                ant1_x_hpol_offset + self.am_vpol.initial_ant1_x,\n                                                ant1_y_hpol_offset + self.am_vpol.initial_ant1_y,\n                                                ant1_z_hpol_offset + self.am_vpol.initial_ant1_z,\n                                                ant2_x_hpol_offset + self.am_vpol.initial_ant2_x,\n                                                ant2_y_hpol_offset + self.am_vpol.initial_ant2_y,\n                                                ant2_z_hpol_offset + self.am_vpol.initial_ant2_z,\n                                                ant3_x_hpol_offset + self.am_vpol.initial_ant3_x,\n                                                ant3_y_hpol_offset + self.am_vpol.initial_ant3_y,\n                                                ant3_z_hpol_offset + self.am_vpol.initial_ant3_z,\n                                                cable_delay0_vpol,\n                                                cable_delay1_vpol,\n                                                cable_delay2_vpol,\n                                                cable_delay3_vpol)\n            return chi_2_hpol + chi_2_vpol\n        except Exception as e:\n            print('\\nError in %s'%inspect.stack()[0][3])\n            print(e)\n            exc_type, exc_obj, exc_tb = sys.exc_info()\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n            print(exc_type, fname, exc_tb.tb_lineno)\n\n\nif __name__ == '__main__':\n    try:\n        plt.close('all')\n        if len(sys.argv) == 2:\n            if str(sys.argv[1]) in ['vpol', 'hpol','both']:\n                pol = str(sys.argv[1])\n                print('POL SET TO %s'%pol)\n            else:\n                print('Given pol not in options.  Defaulting to hpol')\n                pol = 'hpol'\n        else:\n            print('No pol given.  Defaulting to hpol')\n            pol = 'hpol'\n\n        if True:\n            deploy_index = 'rtk-gps-day3-june22-2021.json'#'theodolite-day3-june22-2021_only_enu.json'#'rtk-gps-day3-june22-2021.json'\n            if pol == 'hpol':\n                use_sites = ['d2sa','d3sa','d3sb','d3sc','d4sa','d4sb']\n            elif pol == 'vpol':\n                use_sites = ['d2sa','d3sa','d3sb','d3sc','d4sa','d4sb']\n            elif pol == 'both':\n                use_sites = {}\n                use_sites['hpol'] = ['d2sa','d3sa','d3sb','d3sc','d4sa','d4sb']\n                use_sites['vpol'] = ['d2sa','d3sa','d3sb','d3sc','d4sa','d4sb']\n\n\n\n        plot_histograms = False\n        limit_events = 100\n        plot_time_delays_on_maps = True\n        plot_expected_direction = True\n        \n        iterate_sub_baselines = 6 #The lower this is the higher the time it will take to plot.  Does combinatoric subsets of baselines with this length. \n\n        #Filter settings\n        final_corr_length = 2**16\n        cor_upsample = final_corr_length\n        apply_phase_response = True\n\n        crit_freq_low_pass_MHz = 80\n        low_pass_filter_order = 14\n\n        crit_freq_high_pass_MHz = 20\n        high_pass_filter_order = 4\n\n        sine_subtract = False\n        sine_subtract_min_freq_GHz = 0.02\n        sine_subtract_max_freq_GHz = 0.15\n        sine_subtract_percent = 0.01\n        max_failed_iterations = 3\n\n        plot_filters = False\n        plot_multiple = False\n\n        hilbert = False #Apply hilbert envelope to wf before correlating\n        align_method = 0 \n\n        shorten_signals = True\n        shorten_thresh = 0.7\n        shorten_delay = 10.0\n        shorten_length = 1500.0\n        shorten_keep_leading = 500.0\n\n        waveform_index_range = (None,None)\n\n        random_offset_amount = 0.05#m (every antenna will be stepped randomly by this amount.  Set to 0 if you don't want this. ), Note that this is applied to \n        included_antennas_lumped = [0,1,2,3]#[0,1,2,3] #If an antenna is not in this list then it will not be included in the chi^2 (regardless of if it is fixed or not)  Lumped here imlies that antenna 0 in this list means BOTH channels 0 and 1 (H and V of crossed dipole antenna 0).\n        included_antennas_channels = numpy.concatenate([[2*i,2*i+1] for i in included_antennas_lumped])\n        include_baselines = [0,1,2,3,4,5]#[1,3,5] #Basically sets the starting condition of which baselines to include, then the lumped channels and antennas will cut out further from that.  The above options of excluding antennas will override this to exclude baselines, but if both antennas are included but the baseline is not then it will not be included.  Overwritten when antennas removed.\n\n        #Limits \n        initial_step_x = 0.1#2.0 #m\n        initial_step_y = 0.1#2.0 #m\n        initial_step_z = 0.1#0.75 #m\n        initial_step_cable_delay = 3 #ns\n        cable_delay_guess_range = None#30 #ns\n        antenna_position_guess_range_x = None#0.75 #Limit to how far from input phase locations to limit the parameter space to\n        antenna_position_guess_range_y = None#0.75 #Limit to how far from input phase locations to limit the parameter space to\n        antenna_position_guess_range_z = None#0.75 #Limit to how far from input phase locations to limit the parameter space to\n\n        #Manually shifting input of antenna 0 around so that I can find a fit that has all of its baselines visible for valley sources. \n        manual_offset_ant0_x = 0\n        manual_offset_ant0_y = 0\n        manual_offset_ant0_z = 0\n\n        manual_offset_ant1_x = 0\n        manual_offset_ant1_y = 0\n        manual_offset_ant1_z = 0\n\n        manual_offset_ant2_x = 0\n        manual_offset_ant2_y = 0\n        manual_offset_ant2_z = 0\n\n        manual_offset_ant3_x = 0#2\n        manual_offset_ant3_y = 0#0\n        manual_offset_ant3_z = 0#2\n\n\n        fix_ant0_x = True\n        fix_ant0_y = True\n        fix_ant0_z = True\n        fix_ant1_x = False\n        fix_ant1_y = False\n        fix_ant1_z = False\n        fix_ant2_x = False\n        fix_ant2_y = False\n        fix_ant2_z = False\n        fix_ant3_x = False\n        fix_ant3_y = False\n        fix_ant3_z = False\n        fix_cable_delay0 = True\n        fix_cable_delay1 = False\n        fix_cable_delay2 = False\n        fix_cable_delay3 = False\n\n        origin = info.loadAntennaZeroLocation(deploy_index=deploy_index)\n        if pol != 'both':\n            am = AntennaMinimizer(  pol, \n                                    deploy_index,\n                                    origin=origin,\n                                    use_sites=use_sites, \n                                    random_offset_amount=random_offset_amount,\n                                    included_antennas_lumped=included_antennas_lumped,\n                                    include_baselines=include_baselines,\n                                    initial_step_x=initial_step_x,\n                                    initial_step_y=initial_step_y,\n                                    initial_step_z=initial_step_z,\n                                    initial_step_cable_delay=initial_step_cable_delay,\n                                    cable_delay_guess_range=cable_delay_guess_range,\n                                    antenna_position_guess_range_x=antenna_position_guess_range_x,\n                                    antenna_position_guess_range_y=antenna_position_guess_range_y,\n                                    antenna_position_guess_range_z=antenna_position_guess_range_z,\n                                    manual_offset_ant0_x=manual_offset_ant0_x,\n                                    manual_offset_ant0_y=manual_offset_ant0_y,\n                                    manual_offset_ant0_z=manual_offset_ant0_z,\n                                    manual_offset_ant1_x=manual_offset_ant1_x,\n                                    manual_offset_ant1_y=manual_offset_ant1_y,\n                                    manual_offset_ant1_z=manual_offset_ant1_z,\n                                    manual_offset_ant2_x=manual_offset_ant2_x,\n                                    manual_offset_ant2_y=manual_offset_ant2_y,\n                                    manual_offset_ant2_z=manual_offset_ant2_z,\n                                    manual_offset_ant3_x=manual_offset_ant3_x,\n                                    manual_offset_ant3_y=manual_offset_ant3_y,\n                                    manual_offset_ant3_z=manual_offset_ant3_z,\n                                    fix_ant0_x=fix_ant0_x,\n                                    fix_ant0_y=fix_ant0_y,\n                                    fix_ant0_z=fix_ant0_z,\n                                    fix_ant1_x=fix_ant1_x,\n                                    fix_ant1_y=fix_ant1_y,\n                                    fix_ant1_z=fix_ant1_z,\n                                    fix_ant2_x=fix_ant2_x,\n                                    fix_ant2_y=fix_ant2_y,\n                                    fix_ant2_z=fix_ant2_z,\n                                    fix_ant3_x=fix_ant3_x,\n                                    fix_ant3_y=fix_ant3_y,\n                                    fix_ant3_z=fix_ant3_z,\n                                    fix_cable_delay0=fix_cable_delay0,\n                                    fix_cable_delay1=fix_cable_delay1,\n                                    fix_cable_delay2=fix_cable_delay2,\n                                    fix_cable_delay3=fix_cable_delay3)\n            try:\n                m = Minuit(     am.rawChi2,\\\n                                ant0_x=am.initial_ant0_x,\\\n                                ant0_y=am.initial_ant0_y,\\\n                                ant0_z=am.initial_ant0_z,\\\n                                ant1_x=am.initial_ant1_x,\\\n                                ant1_y=am.initial_ant1_y,\\\n                                ant1_z=am.initial_ant1_z,\\\n                                ant2_x=am.initial_ant2_x,\\\n                                ant2_y=am.initial_ant2_y,\\\n                                ant2_z=am.initial_ant2_z,\\\n                                ant3_x=am.initial_ant3_x,\\\n                                ant3_y=am.initial_ant3_y,\\\n                                ant3_z=am.initial_ant3_z,\\\n                                cable_delay0=am.cable_delays[0],\\\n                                cable_delay1=am.cable_delays[1],\\\n                                cable_delay2=am.cable_delays[2],\\\n                                cable_delay3=am.cable_delays[3],\\\n                                error_ant0_x=am.errors['ant0_x'],\\\n                                error_ant0_y=am.errors['ant0_y'],\\\n                                error_ant0_z=am.errors['ant0_z'],\\\n                                error_ant1_x=am.errors['ant1_x'],\\\n                                error_ant1_y=am.errors['ant1_y'],\\\n                                error_ant1_z=am.errors['ant1_z'],\\\n                                error_ant2_x=am.errors['ant2_x'],\\\n                                error_ant2_y=am.errors['ant2_y'],\\\n                                error_ant2_z=am.errors['ant2_z'],\\\n                                error_ant3_x=am.errors['ant3_x'],\\\n                                error_ant3_y=am.errors['ant3_y'],\\\n                                error_ant3_z=am.errors['ant3_z'],\\\n                                error_cable_delay0=am.errors['cable_delay0'],\\\n                                error_cable_delay1=am.errors['cable_delay1'],\\\n                                error_cable_delay2=am.errors['cable_delay2'],\\\n                                error_cable_delay3=am.errors['cable_delay3'],\\\n                                errordef = am.errordef,\\\n                                limit_ant0_x=am.limits['ant0_x'],\\\n                                limit_ant0_y=am.limits['ant0_y'],\\\n                                limit_ant0_z=am.limits['ant0_z'],\\\n                                limit_ant1_x=am.limits['ant1_x'],\\\n                                limit_ant1_y=am.limits['ant1_y'],\\\n                                limit_ant1_z=am.limits['ant1_z'],\\\n                                limit_ant2_x=am.limits['ant2_x'],\\\n                                limit_ant2_y=am.limits['ant2_y'],\\\n                                limit_ant2_z=am.limits['ant2_z'],\\\n                                limit_ant3_x=am.limits['ant3_x'],\\\n                                limit_ant3_y=am.limits['ant3_y'],\\\n                                limit_ant3_z=am.limits['ant3_z'],\\\n                                limit_cable_delay0=am.limits['cable_delay0'],\\\n                                limit_cable_delay1=am.limits['cable_delay1'],\\\n                                limit_cable_delay2=am.limits['cable_delay2'],\\\n                                limit_cable_delay3=am.limits['cable_delay3'],\\\n                                fix_ant0_x=am.fixed['ant0_x'],\\\n                                fix_ant0_y=am.fixed['ant0_y'],\\\n                                fix_ant0_z=am.fixed['ant0_z'],\\\n                                fix_ant1_x=am.fixed['ant1_x'],\\\n                                fix_ant1_y=am.fixed['ant1_y'],\\\n                                fix_ant1_z=am.fixed['ant1_z'],\\\n                                fix_ant2_x=am.fixed['ant2_x'],\\\n                                fix_ant2_y=am.fixed['ant2_y'],\\\n                                fix_ant2_z=am.fixed['ant2_z'],\\\n                                fix_ant3_x=am.fixed['ant3_x'],\\\n                                fix_ant3_y=am.fixed['ant3_y'],\\\n                                fix_ant3_z=am.fixed['ant3_z'],\\\n                                fix_cable_delay0=am.fixed['cable_delay0'],\\\n                                fix_cable_delay1=am.fixed['cable_delay1'],\\\n                                fix_cable_delay2=am.fixed['cable_delay2'],\\\n                                fix_cable_delay3=am.fixed['cable_delay3'])\n                result = m.migrad(resume=False)\n            except Exception as e:\n                print(e)\n                print('Attempting setup of iminuit again, but assuming newer version of imnuit.')\n                m = Minuit(     am.rawChi2,\\\n                                ant0_x=am.initial_ant0_x,\\\n                                ant0_y=am.initial_ant0_y,\\\n                                ant0_z=am.initial_ant0_z,\\\n                                ant1_x=am.initial_ant1_x,\\\n                                ant1_y=am.initial_ant1_y,\\\n                                ant1_z=am.initial_ant1_z,\\\n                                ant2_x=am.initial_ant2_x,\\\n                                ant2_y=am.initial_ant2_y,\\\n                                ant2_z=am.initial_ant2_z,\\\n                                ant3_x=am.initial_ant3_x,\\\n                                ant3_y=am.initial_ant3_y,\\\n                                ant3_z=am.initial_ant3_z,\\\n                                cable_delay0=am.cable_delays[0],\\\n                                cable_delay1=am.cable_delays[1],\\\n                                cable_delay2=am.cable_delays[2],\\\n                                cable_delay3=am.cable_delays[3])\n\n                m.errors['ant0_x'] = am.errors['ant0_x']\n                m.errors['ant0_y'] = am.errors['ant0_y']\n                m.errors['ant0_z'] = am.errors['ant0_z']\n                m.errors['ant1_x'] = am.errors['ant1_x']\n                m.errors['ant1_y'] = am.errors['ant1_y']\n                m.errors['ant1_z'] = am.errors['ant1_z']\n                m.errors['ant2_x'] = am.errors['ant2_x']\n                m.errors['ant2_y'] = am.errors['ant2_y']\n                m.errors['ant2_z'] = am.errors['ant2_z']\n                m.errors['ant3_x'] = am.errors['ant3_x']\n                m.errors['ant3_y'] = am.errors['ant3_y']\n                m.errors['ant3_z'] = am.errors['ant3_z']\n                m.errors['cable_delay0'] = am.errors['cable_delay0']\n                m.errors['cable_delay1'] = am.errors['cable_delay1']\n                m.errors['cable_delay2'] = am.errors['cable_delay2']\n                m.errors['cable_delay3'] = am.errors['cable_delay3']\n                m.errordef = am.errordef\n                m.limits['ant0_x'] = am.limits['ant0_x']\n                m.limits['ant0_y'] = am.limits['ant0_y']\n                m.limits['ant0_z'] = am.limits['ant0_z']\n                m.limits['ant1_x'] = am.limits['ant1_x']\n                m.limits['ant1_y'] = am.limits['ant1_y']\n                m.limits['ant1_z'] = am.limits['ant1_z']\n                m.limits['ant2_x'] = am.limits['ant2_x']\n                m.limits['ant2_y'] = am.limits['ant2_y']\n                m.limits['ant2_z'] = am.limits['ant2_z']\n                m.limits['ant3_x'] = am.limits['ant3_x']\n                m.limits['ant3_y'] = am.limits['ant3_y']\n                m.limits['ant3_z'] = am.limits['ant3_z']\n                m.limits['cable_delay0'] = am.limits['cable_delay0']\n                m.limits['cable_delay1'] = am.limits['cable_delay1']\n                m.limits['cable_delay2'] = am.limits['cable_delay2']\n                m.limits['cable_delay3'] = am.limits['cable_delay3']\n                m.fixed['ant0_x'] = am.fixed['ant0_x']\n                m.fixed['ant0_y'] = am.fixed['ant0_y']\n                m.fixed['ant0_z'] = am.fixed['ant0_z']\n                m.fixed['ant1_x'] = am.fixed['ant1_x']\n                m.fixed['ant1_y'] = am.fixed['ant1_y']\n                m.fixed['ant1_z'] = am.fixed['ant1_z']\n                m.fixed['ant2_x'] = am.fixed['ant2_x']\n                m.fixed['ant2_y'] = am.fixed['ant2_y']\n                m.fixed['ant2_z'] = am.fixed['ant2_z']\n                m.fixed['ant3_x'] = am.fixed['ant3_x']\n                m.fixed['ant3_y'] = am.fixed['ant3_y']\n                m.fixed['ant3_z'] = am.fixed['ant3_z']\n                m.fixed['cable_delay0'] = am.fixed['cable_delay0']\n                m.fixed['cable_delay1'] = am.fixed['cable_delay1']\n                m.fixed['cable_delay2'] = am.fixed['cable_delay2']\n                m.fixed['cable_delay3'] = am.fixed['cable_delay3']\n\n                result = m.migrad()\n\n\n            print(result)\n            m.hesse()\n            if True:\n                m.minos()\n                pprint(m.get_fmin())\n            else:\n                try:\n                    m.minos()\n                    pprint(m.get_fmin())\n                except:\n                    print('MINOS FAILED, NOT VALID SOLUTION.')\n            print('\\a')\n        else:\n            am_hpol = AntennaMinimizer( 'hpol', \n                                        deploy_index,\n                                        origin=origin,\n                                        use_sites=use_sites['hpol'], \n                                        random_offset_amount=random_offset_amount,\n                                        included_antennas_lumped=included_antennas_lumped,\n                                        include_baselines=include_baselines,\n                                        initial_step_x=initial_step_x,\n                                        initial_step_y=initial_step_y,\n                                        initial_step_z=initial_step_z,\n                                        initial_step_cable_delay=initial_step_cable_delay,\n                                        cable_delay_guess_range=cable_delay_guess_range,\n                                        antenna_position_guess_range_x=antenna_position_guess_range_x,\n                                        antenna_position_guess_range_y=antenna_position_guess_range_y,\n                                        antenna_position_guess_range_z=antenna_position_guess_range_z,\n                                        manual_offset_ant0_x=manual_offset_ant0_x,\n                                        manual_offset_ant0_y=manual_offset_ant0_y,\n                                        manual_offset_ant0_z=manual_offset_ant0_z,\n                                        manual_offset_ant1_x=manual_offset_ant1_x,\n                                        manual_offset_ant1_y=manual_offset_ant1_y,\n                                        manual_offset_ant1_z=manual_offset_ant1_z,\n                                        manual_offset_ant2_x=manual_offset_ant2_x,\n                                        manual_offset_ant2_y=manual_offset_ant2_y,\n                                        manual_offset_ant2_z=manual_offset_ant2_z,\n                                        manual_offset_ant3_x=manual_offset_ant3_x,\n                                        manual_offset_ant3_y=manual_offset_ant3_y,\n                                        manual_offset_ant3_z=manual_offset_ant3_z,\n                                        fix_ant0_x=fix_ant0_x,\n                                        fix_ant0_y=fix_ant0_y,\n                                        fix_ant0_z=fix_ant0_z,\n                                        fix_ant1_x=fix_ant1_x,\n                                        fix_ant1_y=fix_ant1_y,\n                                        fix_ant1_z=fix_ant1_z,\n                                        fix_ant2_x=fix_ant2_x,\n                                        fix_ant2_y=fix_ant2_y,\n                                        fix_ant2_z=fix_ant2_z,\n                                        fix_ant3_x=fix_ant3_x,\n                                        fix_ant3_y=fix_ant3_y,\n                                        fix_ant3_z=fix_ant3_z,\n                                        fix_cable_delay0=fix_cable_delay0,\n                                        fix_cable_delay1=fix_cable_delay1,\n                                        fix_cable_delay2=fix_cable_delay2,\n                                        fix_cable_delay3=fix_cable_delay3)\n            am_vpol = AntennaMinimizer( 'vpol', \n                                        deploy_index,\n                                        origin=origin,\n                                        use_sites=use_sites['vpol'], \n                                        random_offset_amount=random_offset_amount,\n                                        included_antennas_lumped=included_antennas_lumped,\n                                        include_baselines=include_baselines,\n                                        initial_step_x=initial_step_x,\n                                        initial_step_y=initial_step_y,\n                                        initial_step_z=initial_step_z,\n                                        initial_step_cable_delay=initial_step_cable_delay,\n                                        cable_delay_guess_range=cable_delay_guess_range,\n                                        antenna_position_guess_range_x=antenna_position_guess_range_x,\n                                        antenna_position_guess_range_y=antenna_position_guess_range_y,\n                                        antenna_position_guess_range_z=antenna_position_guess_range_z,\n                                        manual_offset_ant0_x=manual_offset_ant0_x,\n                                        manual_offset_ant0_y=manual_offset_ant0_y,\n                                        manual_offset_ant0_z=manual_offset_ant0_z,\n                                        manual_offset_ant1_x=manual_offset_ant1_x,\n                                        manual_offset_ant1_y=manual_offset_ant1_y,\n                                        manual_offset_ant1_z=manual_offset_ant1_z,\n                                        manual_offset_ant2_x=manual_offset_ant2_x,\n                                        manual_offset_ant2_y=manual_offset_ant2_y,\n                                        manual_offset_ant2_z=manual_offset_ant2_z,\n                                        manual_offset_ant3_x=manual_offset_ant3_x,\n                                        manual_offset_ant3_y=manual_offset_ant3_y,\n                                        manual_offset_ant3_z=manual_offset_ant3_z,\n                                        fix_ant0_x=fix_ant0_x,\n                                        fix_ant0_y=fix_ant0_y,\n                                        fix_ant0_z=fix_ant0_z,\n                                        fix_ant1_x=fix_ant1_x,\n                                        fix_ant1_y=fix_ant1_y,\n                                        fix_ant1_z=fix_ant1_z,\n                                        fix_ant2_x=fix_ant2_x,\n                                        fix_ant2_y=fix_ant2_y,\n                                        fix_ant2_z=fix_ant2_z,\n                                        fix_ant3_x=fix_ant3_x,\n                                        fix_ant3_y=fix_ant3_y,\n                                        fix_ant3_z=fix_ant3_z,\n                                        fix_cable_delay0=fix_cable_delay0,\n                                        fix_cable_delay1=fix_cable_delay1,\n                                        fix_cable_delay2=fix_cable_delay2,\n                                        fix_cable_delay3=fix_cable_delay3)\n\n            cm = CombinedAntennaMinimizer(am_hpol, am_vpol)\n            try:\n                m = Minuit(     cm.rawChi2,\\\n                                ant0_x_hpol=cm.am_hpol.initial_ant0_x,\\\n                                ant0_y_hpol=cm.am_hpol.initial_ant0_y,\\\n                                ant0_z_hpol=cm.am_hpol.initial_ant0_z,\\\n                                ant1_x_hpol=cm.am_hpol.initial_ant1_x,\\\n                                ant1_y_hpol=cm.am_hpol.initial_ant1_y,\\\n                                ant1_z_hpol=cm.am_hpol.initial_ant1_z,\\\n                                ant2_x_hpol=cm.am_hpol.initial_ant2_x,\\\n                                ant2_y_hpol=cm.am_hpol.initial_ant2_y,\\\n                                ant2_z_hpol=cm.am_hpol.initial_ant2_z,\\\n                                ant3_x_hpol=cm.am_hpol.initial_ant3_x,\\\n                                ant3_y_hpol=cm.am_hpol.initial_ant3_y,\\\n                                ant3_z_hpol=cm.am_hpol.initial_ant3_z,\\\n                                cable_delay0_hpol=cm.am_hpol.cable_delays[0],\\\n                                cable_delay1_hpol=cm.am_hpol.cable_delays[1],\\\n                                cable_delay2_hpol=cm.am_hpol.cable_delays[2],\\\n                                cable_delay3_hpol=cm.am_hpol.cable_delays[3],\\\n                                cable_delay0_vpol=cm.am_vpol.cable_delays[0],\\\n                                cable_delay1_vpol=cm.am_vpol.cable_delays[1],\\\n                                cable_delay2_vpol=cm.am_vpol.cable_delays[2],\\\n                                cable_delay3_vpol=cm.am_vpol.cable_delays[3],\\\n                                error_ant0_x_hpol=cm.am_hpol.errors['ant0_x'],\\\n                                error_ant0_y_hpol=cm.am_hpol.errors['ant0_y'],\\\n                                error_ant0_z_hpol=cm.am_hpol.errors['ant0_z'],\\\n                                error_ant1_x_hpol=cm.am_hpol.errors['ant1_x'],\\\n                                error_ant1_y_hpol=cm.am_hpol.errors['ant1_y'],\\\n                                error_ant1_z_hpol=cm.am_hpol.errors['ant1_z'],\\\n                                error_ant2_x_hpol=cm.am_hpol.errors['ant2_x'],\\\n                                error_ant2_y_hpol=cm.am_hpol.errors['ant2_y'],\\\n                                error_ant2_z_hpol=cm.am_hpol.errors['ant2_z'],\\\n                                error_ant3_x_hpol=cm.am_hpol.errors['ant3_x'],\\\n                                error_ant3_y_hpol=cm.am_hpol.errors['ant3_y'],\\\n                                error_ant3_z_hpol=cm.am_hpol.errors['ant3_z'],\\\n                                error_cable_delay0_hpol=cm.am_hpol.errors['cable_delay0'],\\\n                                error_cable_delay1_hpol=cm.am_hpol.errors['cable_delay1'],\\\n                                error_cable_delay2_hpol=cm.am_hpol.errors['cable_delay2'],\\\n                                error_cable_delay3_hpol=cm.am_hpol.errors['cable_delay3'],\\\n                                error_cable_delay0_vpol=cm.am_vpol.errors['cable_delay0'],\\\n                                error_cable_delay1_vpol=cm.am_vpol.errors['cable_delay1'],\\\n                                error_cable_delay2_vpol=cm.am_vpol.errors['cable_delay2'],\\\n                                error_cable_delay3_vpol=cm.am_vpol.errors['cable_delay3'],\\\n                                errordef = cm.am_hpol.errordef,\\\n                                limit_ant0_x_hpol=cm.am_hpol.limits['ant0_x'],\\\n                                limit_ant0_y_hpol=cm.am_hpol.limits['ant0_y'],\\\n                                limit_ant0_z_hpol=cm.am_hpol.limits['ant0_z'],\\\n                                limit_ant1_x_hpol=cm.am_hpol.limits['ant1_x'],\\\n                                limit_ant1_y_hpol=cm.am_hpol.limits['ant1_y'],\\\n                                limit_ant1_z_hpol=cm.am_hpol.limits['ant1_z'],\\\n                                limit_ant2_x_hpol=cm.am_hpol.limits['ant2_x'],\\\n                                limit_ant2_y_hpol=cm.am_hpol.limits['ant2_y'],\\\n                                limit_ant2_z_hpol=cm.am_hpol.limits['ant2_z'],\\\n                                limit_ant3_x_hpol=cm.am_hpol.limits['ant3_x'],\\\n                                limit_ant3_y_hpol=cm.am_hpol.limits['ant3_y'],\\\n                                limit_ant3_z_hpol=cm.am_hpol.limits['ant3_z'],\\\n                                limit_cable_delay0_hpol=cm.am_hpol.limits['cable_delay0'],\\\n                                limit_cable_delay1_hpol=cm.am_hpol.limits['cable_delay1'],\\\n                                limit_cable_delay2_hpol=cm.am_hpol.limits['cable_delay2'],\\\n                                limit_cable_delay3_hpol=cm.am_hpol.limits['cable_delay3'],\\\n                                limit_cable_delay0_vpol=cm.am_vpol.limits['cable_delay0'],\\\n                                limit_cable_delay1_vpol=cm.am_vpol.limits['cable_delay1'],\\\n                                limit_cable_delay2_vpol=cm.am_vpol.limits['cable_delay2'],\\\n                                limit_cable_delay3_vpol=cm.am_vpol.limits['cable_delay3'],\\\n                                fix_ant0_x_hpol=cm.am_hpol.fixed['ant0_x'],\\\n                                fix_ant0_y_hpol=cm.am_hpol.fixed['ant0_y'],\\\n                                fix_ant0_z_hpol=cm.am_hpol.fixed['ant0_z'],\\\n                                fix_ant1_x_hpol=cm.am_hpol.fixed['ant1_x'],\\\n                                fix_ant1_y_hpol=cm.am_hpol.fixed['ant1_y'],\\\n                                fix_ant1_z_hpol=cm.am_hpol.fixed['ant1_z'],\\\n                                fix_ant2_x_hpol=cm.am_hpol.fixed['ant2_x'],\\\n                                fix_ant2_y_hpol=cm.am_hpol.fixed['ant2_y'],\\\n                                fix_ant2_z_hpol=cm.am_hpol.fixed['ant2_z'],\\\n                                fix_ant3_x_hpol=cm.am_hpol.fixed['ant3_x'],\\\n                                fix_ant3_y_hpol=cm.am_hpol.fixed['ant3_y'],\\\n                                fix_ant3_z_hpol=cm.am_hpol.fixed['ant3_z'],\\\n                                fix_cable_delay0_hpol=cm.am_hpol.fixed['cable_delay0'],\\\n                                fix_cable_delay1_hpol=cm.am_hpol.fixed['cable_delay1'],\\\n                                fix_cable_delay2_hpol=cm.am_hpol.fixed['cable_delay2'],\\\n                                fix_cable_delay3_hpol=cm.am_hpol.fixed['cable_delay3'],\\\n                                fix_cable_delay0_vpol=cm.am_vpol.fixed['cable_delay0'],\\\n                                fix_cable_delay1_vpol=cm.am_vpol.fixed['cable_delay1'],\\\n                                fix_cable_delay2_vpol=cm.am_vpol.fixed['cable_delay2'],\\\n                                fix_cable_delay3_vpol=cm.am_vpol.fixed['cable_delay3'])\n                result = m.migrad(resume=False)\n            except Exception as e:\n                print(e)\n                print('Attempting setup of iminuit again, but assuming newer version of imnuit.')\n                m = Minuit(     am.rawChi2,\\\n                                ant0_x_hpol=cm.am_hpol.initial_ant0_x,\\\n                                ant0_y_hpol=cm.am_hpol.initial_ant0_y,\\\n                                ant0_z_hpol=cm.am_hpol.initial_ant0_z,\\\n                                ant1_x_hpol=cm.am_hpol.initial_ant1_x,\\\n                                ant1_y_hpol=cm.am_hpol.initial_ant1_y,\\\n                                ant1_z_hpol=cm.am_hpol.initial_ant1_z,\\\n                                ant2_x_hpol=cm.am_hpol.initial_ant2_x,\\\n                                ant2_y_hpol=cm.am_hpol.initial_ant2_y,\\\n                                ant2_z_hpol=cm.am_hpol.initial_ant2_z,\\\n                                ant3_x_hpol=cm.am_hpol.initial_ant3_x,\\\n                                ant3_y_hpol=cm.am_hpol.initial_ant3_y,\\\n                                ant3_z_hpol=cm.am_hpol.initial_ant3_z,\\\n                                cable_delay0_hpol=cm.am_hpol.cable_delays[0],\\\n                                cable_delay1_hpol=cm.am_hpol.cable_delays[1],\\\n                                cable_delay2_hpol=cm.am_hpol.cable_delays[2],\\\n                                cable_delay3_hpol=cm.am_hpol.cable_delays[3],\\\n                                cable_delay0_vpol=cm.am_vpol.cable_delays[0],\\\n                                cable_delay1_vpol=cm.am_vpol.cable_delays[1],\\\n                                cable_delay2_vpol=cm.am_vpol.cable_delays[2],\\\n                                cable_delay3_vpol=cm.am_vpol.cable_delays[3])\n\n                m.errors['ant0_x_hpol'] = cm.am_hpol.errors['ant0_x']\n                m.errors['ant0_y_hpol'] = cm.am_hpol.errors['ant0_y']\n                m.errors['ant0_z_hpol'] = cm.am_hpol.errors['ant0_z']\n                m.errors['ant1_x_hpol'] = cm.am_hpol.errors['ant1_x']\n                m.errors['ant1_y_hpol'] = cm.am_hpol.errors['ant1_y']\n                m.errors['ant1_z_hpol'] = cm.am_hpol.errors['ant1_z']\n                m.errors['ant2_x_hpol'] = cm.am_hpol.errors['ant2_x']\n                m.errors['ant2_y_hpol'] = cm.am_hpol.errors['ant2_y']\n                m.errors['ant2_z_hpol'] = cm.am_hpol.errors['ant2_z']\n                m.errors['ant3_x_hpol'] = cm.am_hpol.errors['ant3_x']\n                m.errors['ant3_y_hpol'] = cm.am_hpol.errors['ant3_y']\n                m.errors['ant3_z_hpol'] = cm.am_hpol.errors['ant3_z']\n                m.errors['cable_delay0_hpol'] = cm.am_hpol.errors['cable_delay0']\n                m.errors['cable_delay1_hpol'] = cm.am_hpol.errors['cable_delay1']\n                m.errors['cable_delay2_hpol'] = cm.am_hpol.errors['cable_delay2']\n                m.errors['cable_delay3_hpol'] = cm.am_hpol.errors['cable_delay3']\n                m.errors['cable_delay0_vpol'] = cm.am_vpol.errors['cable_delay0']\n                m.errors['cable_delay1_vpol'] = cm.am_vpol.errors['cable_delay1']\n                m.errors['cable_delay2_vpol'] = cm.am_vpol.errors['cable_delay2']\n                m.errors['cable_delay3_vpol'] = cm.am_vpol.errors['cable_delay3']\n                m.errordef = cm.am_hpol.errordef\n                m.limits['ant0_x_hpol'] = cm.am_hpol.limits['ant0_x']\n                m.limits['ant0_y_hpol'] = cm.am_hpol.limits['ant0_y']\n                m.limits['ant0_z_hpol'] = cm.am_hpol.limits['ant0_z']\n                m.limits['ant1_x_hpol'] = cm.am_hpol.limits['ant1_x']\n                m.limits['ant1_y_hpol'] = cm.am_hpol.limits['ant1_y']\n                m.limits['ant1_z_hpol'] = cm.am_hpol.limits['ant1_z']\n                m.limits['ant2_x_hpol'] = cm.am_hpol.limits['ant2_x']\n                m.limits['ant2_y_hpol'] = cm.am_hpol.limits['ant2_y']\n                m.limits['ant2_z_hpol'] = cm.am_hpol.limits['ant2_z']\n                m.limits['ant3_x_hpol'] = cm.am_hpol.limits['ant3_x']\n                m.limits['ant3_y_hpol'] = cm.am_hpol.limits['ant3_y']\n                m.limits['ant3_z_hpol'] = cm.am_hpol.limits['ant3_z']\n                m.limits['cable_delay0_hpol'] = cm.am_hpol.limits['cable_delay0']\n                m.limits['cable_delay1_hpol'] = cm.am_hpol.limits['cable_delay1']\n                m.limits['cable_delay2_hpol'] = cm.am_hpol.limits['cable_delay2']\n                m.limits['cable_delay3_hpol'] = cm.am_hpol.limits['cable_delay3']\n                m.limits['cable_delay0_vpol'] = cm.am_vpol.limits['cable_delay0']\n                m.limits['cable_delay1_vpol'] = cm.am_vpol.limits['cable_delay1']\n                m.limits['cable_delay2_vpol'] = cm.am_vpol.limits['cable_delay2']\n                m.limits['cable_delay3_vpol'] = cm.am_vpol.limits['cable_delay3']\n                m.fixed['ant0_x_hpol'] = cm.am_hpol.fixed['ant0_x']\n                m.fixed['ant0_y_hpol'] = cm.am_hpol.fixed['ant0_y']\n                m.fixed['ant0_z_hpol'] = cm.am_hpol.fixed['ant0_z']\n                m.fixed['ant1_x_hpol'] = cm.am_hpol.fixed['ant1_x']\n                m.fixed['ant1_y_hpol'] = cm.am_hpol.fixed['ant1_y']\n                m.fixed['ant1_z_hpol'] = cm.am_hpol.fixed['ant1_z']\n                m.fixed['ant2_x_hpol'] = cm.am_hpol.fixed['ant2_x']\n                m.fixed['ant2_y_hpol'] = cm.am_hpol.fixed['ant2_y']\n                m.fixed['ant2_z_hpol'] = cm.am_hpol.fixed['ant2_z']\n                m.fixed['ant3_x_hpol'] = cm.am_hpol.fixed['ant3_x']\n                m.fixed['ant3_y_hpol'] = cm.am_hpol.fixed['ant3_y']\n                m.fixed['ant3_z_hpol'] = cm.am_hpol.fixed['ant3_z']\n                m.fixed['cable_delay0_hpol'] = cm.am_hpol.fixed['cable_delay0']\n                m.fixed['cable_delay1_hpol'] = cm.am_hpol.fixed['cable_delay1']\n                m.fixed['cable_delay2_hpol'] = cm.am_hpol.fixed['cable_delay2']\n                m.fixed['cable_delay3_hpol'] = cm.am_hpol.fixed['cable_delay3']\n                m.fixed['cable_delay0_vpol'] = cm.am_vpol.fixed['cable_delay0']\n                m.fixed['cable_delay1_vpol'] = cm.am_vpol.fixed['cable_delay1']\n                m.fixed['cable_delay2_vpol'] = cm.am_vpol.fixed['cable_delay2']\n                m.fixed['cable_delay3_vpol'] = cm.am_vpol.fixed['cable_delay3']\n\n                result = m.migrad()\n\n\n            print(result)\n            m.hesse()\n            if True:\n                m.minos()\n                pprint(m.get_fmin())\n            else:\n                try:\n                    m.minos()\n                    pprint(m.get_fmin())\n                except:\n                    print('MINOS FAILED, NOT VALID SOLUTION.')\n            print('\\a')\n\n        # # ##########\n        # # Plot Setup\n        # # ##########\n        if pol != 'both':\n            chi2_fig = plt.figure()\n            chi2_fig.canvas.set_window_title('Initial Positions')\n            chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n            if 0 in am.included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant0_x, am.initial_ant0_y, am.initial_ant0_z,c='r',alpha=0.5,label='Initial Ant0')\n            if 1 in am.included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant1_x, am.initial_ant1_y, am.initial_ant1_z,c='g',alpha=0.5,label='Initial Ant1')\n            if 2 in am.included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant2_x, am.initial_ant2_y, am.initial_ant2_z,c='b',alpha=0.5,label='Initial Ant2')\n            if 3 in am.included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant3_x, am.initial_ant3_y, am.initial_ant3_z,c='m',alpha=0.5,label='Initial Ant3')\n\n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            \n            chi2_ax.dist = 10\n            plt.legend()\n            \n            chi2_fig = plt.figure()\n            chi2_fig.canvas.set_window_title('Both')\n            chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n            if 0 in included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant0_x, am.initial_ant0_y, am.initial_ant0_z,c='r',alpha=0.5,label='Initial Ant0')\n            if 1 in included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant1_x, am.initial_ant1_y, am.initial_ant1_z,c='g',alpha=0.5,label='Initial Ant1')\n            if 2 in included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant2_x, am.initial_ant2_y, am.initial_ant2_z,c='b',alpha=0.5,label='Initial Ant2')\n            if 3 in included_antennas_lumped:\n                chi2_ax.scatter(am.initial_ant3_x, am.initial_ant3_y, am.initial_ant3_z,c='m',alpha=0.5,label='Initial Ant3')\n\n            for antenna in range(4):\n                fig = plt.figure()\n                fig.canvas.set_window_title('Ant %i chi^2'%antenna)\n                for index, key in enumerate(['ant%i_x'%antenna,'ant%i_y'%antenna,'ant%i_z'%antenna]):\n                    plt.subplot(1,3,index + 1)\n                    m.draw_profile(key)\n\n            if cable_delay_guess_range is not None:\n                fig = plt.figure()\n                fig.canvas.set_window_title('Cable Delays')\n                for antenna in range(4):\n                    plt.subplot(2,2,antenna + 1)\n                    m.draw_profile('cable_delay%i'%antenna)\n\n            #12 variables\n            ant0_phase_x = m.values['ant0_x']\n            ant0_phase_y = m.values['ant0_y']\n            ant0_phase_z = m.values['ant0_z']\n            ant0_cable_delay = m.values['cable_delay0']\n\n            ant1_phase_x = m.values['ant1_x']\n            ant1_phase_y = m.values['ant1_y']\n            ant1_phase_z = m.values['ant1_z']\n            ant1_cable_delay = m.values['cable_delay1']\n\n            ant2_phase_x = m.values['ant2_x']\n            ant2_phase_y = m.values['ant2_y']\n            ant2_phase_z = m.values['ant2_z']\n            ant2_cable_delay = m.values['cable_delay2']\n\n            ant3_phase_x = m.values['ant3_x']\n            ant3_phase_y = m.values['ant3_y']\n            ant3_phase_z = m.values['ant3_z']\n            ant3_cable_delay = m.values['cable_delay3']\n\n            ant0_ENU = numpy.array([ant0_phase_x, ant0_phase_y, ant0_phase_z])\n            ant1_ENU = numpy.array([ant1_phase_x, ant1_phase_y, ant1_phase_z])\n            ant2_ENU = numpy.array([ant2_phase_x, ant2_phase_y, ant2_phase_z])\n            ant3_ENU = numpy.array([ant3_phase_x, ant3_phase_y, ant3_phase_z])\n            resulting_cable_delays = numpy.array([ant0_cable_delay,ant1_cable_delay,ant2_cable_delay,ant3_cable_delay])\n\n            output_antennas_phase = {0:ant0_ENU, 1:ant1_ENU, 2:ant2_ENU, 3:ant3_ENU}\n\n            chi2_ax.plot([am.initial_ant0_x , ant0_phase_x], [am.initial_ant0_y , ant0_phase_y], [am.initial_ant0_z , ant0_phase_z],c='r',alpha=0.5,linestyle='--')\n            chi2_ax.plot([am.initial_ant1_x , ant1_phase_x], [am.initial_ant1_y , ant1_phase_y], [am.initial_ant1_z , ant1_phase_z],c='g',alpha=0.5,linestyle='--')\n            chi2_ax.plot([am.initial_ant2_x , ant2_phase_x], [am.initial_ant2_y , ant2_phase_y], [am.initial_ant2_z , ant2_phase_z],c='b',alpha=0.5,linestyle='--')\n            chi2_ax.plot([am.initial_ant3_x , ant3_phase_x], [am.initial_ant3_y , ant3_phase_y], [am.initial_ant3_z , ant3_phase_z],c='m',alpha=0.5,linestyle='--')\n\n            chi2_ax.scatter(ant0_phase_x, ant0_phase_y, ant0_phase_z,marker='*',c='r',alpha=0.5,label='Final Ant0')\n            chi2_ax.scatter(ant1_phase_x, ant1_phase_y, ant1_phase_z,marker='*',c='g',alpha=0.5,label='Final Ant1')\n            chi2_ax.scatter(ant2_phase_x, ant2_phase_y, ant2_phase_z,marker='*',c='b',alpha=0.5,label='Final Ant2')\n            chi2_ax.scatter(ant3_phase_x, ant3_phase_y, ant3_phase_z,marker='*',c='m',alpha=0.5,label='Final Ant3')\n            \n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            chi2_ax.dist = 10\n            plt.legend()\n\n\n\n            chi2_fig = plt.figure()\n            chi2_fig.canvas.set_window_title('Final Positions')\n            chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n            if 0 in included_antennas_lumped:\n                chi2_ax.scatter(ant0_phase_x, ant0_phase_y, ant0_phase_z,marker='*',c='r',alpha=0.5,label='Final Ant0')\n            if 1 in included_antennas_lumped:\n                chi2_ax.scatter(ant1_phase_x, ant1_phase_y, ant1_phase_z,marker='*',c='g',alpha=0.5,label='Final Ant1')\n            if 2 in included_antennas_lumped:\n                chi2_ax.scatter(ant2_phase_x, ant2_phase_y, ant2_phase_z,marker='*',c='b',alpha=0.5,label='Final Ant2')\n            if 3 in included_antennas_lumped:\n                chi2_ax.scatter(ant3_phase_x, ant3_phase_y, ant3_phase_z,marker='*',c='m',alpha=0.5,label='Final Ant3')\n\n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            chi2_ax.dist = 10\n            plt.legend()\n\n            #Plot Pulser Events\n            pulser_info = PulserInfo()\n            for key in am.use_sites:\n                #Calculate old and new geometries\n                #Distance needed when calling correlator, as it uses that distance.\n                original_pulser_ENU = numpy.array([am.pulser_locations_ENU[key][0] , am.pulser_locations_ENU[key][1] , am.pulser_locations_ENU[key][2]])\n                original_distance_m = numpy.linalg.norm(original_pulser_ENU)\n                original_zenith_deg = numpy.rad2deg(numpy.arccos(original_pulser_ENU[2]/original_distance_m))\n                original_elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(original_pulser_ENU[2]/original_distance_m))\n                original_azimuth_deg = numpy.rad2deg(numpy.arctan2(original_pulser_ENU[1],original_pulser_ENU[0]))\n\n                pulser_ENU_new = numpy.array([am.pulser_locations_ENU[key][0] - ant0_ENU[0] , am.pulser_locations_ENU[key][1] - ant0_ENU[1] , am.pulser_locations_ENU[key][2] - ant0_ENU[2]])\n                distance_m = numpy.linalg.norm(pulser_ENU_new)\n                zenith_deg = numpy.rad2deg(numpy.arccos(pulser_ENU_new[2]/distance_m))\n                elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(pulser_ENU_new[2]/distance_m))\n                azimuth_deg = numpy.rad2deg(numpy.arctan2(pulser_ENU_new[1],pulser_ENU_new[0]))\n\n                map_resolution = 0.25 #degrees\n                range_phi_deg = (-90, 90)\n                range_theta_deg = (80,120)\n                n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                \n\n                known_pulser_ids = info.load2021PulserEventids()[key][pol]\n                known_pulser_ids = known_pulser_ids[numpy.isin(known_pulser_ids['attenuation_dB'], attenuations_dict[pol][key])]\n                reference_event  = pulser_info.getPulserReferenceEvent(key, pol)\n                if True:\n                    event_info = reference_event\n                else:\n                    event_info = numpy.random.choice(known_pulser_ids)\n\n                reader = Reader(datapath,int(event_info['run']))\n                \n                cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n\n                if pol == 'hpol':\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,am.initial_ant0_ENU,am.initial_ant1_ENU,am.initial_ant2_ENU,am.initial_ant3_ENU,cor.A0_vpol,cor.A1_vpol,cor.A2_vpol,cor.A3_vpol,verbose=False)\n                elif pol == 'vpol':\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cor.A0_hpol,cor.A1_hpol,cor.A2_hpol,cor.A3_hpol,am.initial_ant0_ENU,am.initial_ant1_ENU,am.initial_ant2_ENU,am.initial_ant3_ENU,verbose=False)\n\n\n                adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                if pol == 'hpol':\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                    adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                else:\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                    adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])                    \n\n                if plot_expected_direction == False:\n                    zenith_deg = None\n                    azimuth_deg = None\n\n                if plot_time_delays_on_maps:\n                    if False:\n                        #Good for troubleshooting if a cycle slipped.\n                        cycle_slip_estimate_ns = 15\n                        n_cycles = 1\n                        td_dict = {pol:{'[0, 1]' :  measured_time_delays[key][pol]['delays_ns'][0] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[0, 2]' : measured_time_delays[key][pol]['delays_ns'][1] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[0, 3]' : measured_time_delays[key][pol]['delays_ns'][2] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[1, 2]' : measured_time_delays[key][pol]['delays_ns'][3] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[1, 3]' : measured_time_delays[key][pol]['delays_ns'][4] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[2, 3]' : measured_time_delays[key][pol]['delays_ns'][5] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns}}\n                    else:\n                        td_dict = {pol:{'[0, 1]' :  [measured_time_delays[key][pol]['delays_ns'][0]], '[0, 2]' : [measured_time_delays[key][pol]['delays_ns'][1]], '[0, 3]' : [measured_time_delays[key][pol]['delays_ns'][2]], '[1, 2]' : [measured_time_delays[key][pol]['delays_ns'][3]], '[1, 3]' : [measured_time_delays[key][pol]['delays_ns'][4]], '[2, 3]' : [measured_time_delays[key][pol]['delays_ns'][5]]}}\n                else:\n                    td_dict = {}\n\n\n                #mean_corr_values, fig, ax = cor.map(int(event_info['eventid']), pol, include_baselines=include_baselines, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict,shorten_signals=shorten_signals, shorten_thresh=shorten_thresh, shorten_delay=shorten_delay, shorten_length=shorten_length, shorten_keep_leading=shorten_keep_leading)\n                adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(int(event_info['eventid']), pol, include_baselines=include_baselines, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict,shorten_signals=shorten_signals, shorten_thresh=shorten_thresh, shorten_delay=shorten_delay, shorten_length=shorten_length, shorten_keep_leading=shorten_keep_leading)\n                adjusted_fig.set_size_inches(16, 9)\n                plt.sca(adjusted_ax)\n                plt.tight_layout()\n                adjusted_fig.savefig('./%s.png'%key,dpi=90)\n\n                if plot_histograms:\n                    map_resolution = 0.1 #degrees\n                    range_phi_deg=(azimuth_deg - 10, azimuth_deg + 10)\n                    range_theta_deg=(zenith_deg - 10,zenith_deg + 10)\n                    n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                    n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                                    \n                    cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                    cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                    adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    if pol == 'hpol':\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                        adjusted_cor.overwriteCableDelays(m.values['cable_delay0'], adjusted_cor.cable_delays[1], m.values['cable_delay1'], adjusted_cor.cable_delays[3], m.values['cable_delay2'], adjusted_cor.cable_delays[5], m.values['cable_delay3'], adjusted_cor.cable_delays[7])\n                    else:\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,adjusted_cor.A0_hpol,adjusted_cor.A1_hpol,adjusted_cor.A2_hpol,adjusted_cor.A3_hpol,ant0_ENU,ant1_ENU,ant2_ENU,ant3_ENU,verbose=False)\n                        adjusted_cor.overwriteCableDelays(adjusted_cor.cable_delays[0], m.values['cable_delay0'], adjusted_cor.cable_delays[2], m.values['cable_delay1'], adjusted_cor.cable_delays[4], m.values['cable_delay2'], adjusted_cor.cable_delays[6], m.values['cable_delay3'])                    \n\n                    \n                    run_cut = known_pulser_ids['run'] == reader.run #Make sure all eventids in same run\n                    hist = adjusted_cor.histMapPeak(numpy.sort(numpy.random.choice(known_pulser_ids[run_cut],min(limit_events,len(known_pulser_ids[run_cut]))))['eventid'], pol, plot_map=True, hilbert=False, max_method=0, use_weight=False, mollweide=False, center_dir='E', radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90],circle_zenith=zenith_deg, circle_az=azimuth_deg, window_title='Hist ' + key, include_baselines=include_baselines,iterate_sub_baselines=iterate_sub_baselines)\n\n            # Finalized Output \n            print('Estimated degrees of freedom: %i'%sum([not v for k, v in m.fixed.items()]))\n            print('Estimated input measured values: %i'%(len(am.include_baselines)*len(am.use_sites) + len(am.include_baselines)*len(am.use_sites)))\n\n\n            print('\\n')\n            print('STARTING CONDITION INPUT VALUES HERE')\n            print('\\n')\n            print('')\n            print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%(pol, am.initial_ant0_x,am.initial_ant0_y,am.initial_ant0_z ,  am.initial_ant1_x,am.initial_ant1_y,am.initial_ant1_z,  am.initial_ant2_x,am.initial_ant2_y,am.initial_ant2_z,  am.initial_ant3_x,am.initial_ant3_y,am.initial_ant3_z))\n            print('')\n            print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%(pol,am.cable_delays[0],am.cable_delays[1],am.cable_delays[2],am.cable_delays[3]))\n\n\n\n            print('\\n')\n            print(result)\n            print('\\n')\n            print('Copy-Paste Prints:\\n------------')\n            print('')\n            print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%(pol, m.values['ant0_x'],m.values['ant0_y'],m.values['ant0_z'] ,  m.values['ant1_x'],m.values['ant1_y'],m.values['ant1_z'],  m.values['ant2_x'],m.values['ant2_y'],m.values['ant2_z'],  m.values['ant3_x'],m.values['ant3_y'],m.values['ant3_z']))\n            print('antennas_phase_%s_hesse = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%(pol, m.errors['ant0_x'],m.errors['ant0_y'],m.errors['ant0_z'] ,  m.errors['ant1_x'],m.errors['ant1_y'],m.errors['ant1_z'],  m.errors['ant2_x'],m.errors['ant2_y'],m.errors['ant2_z'],  m.errors['ant3_x'],m.errors['ant3_y'],m.errors['ant3_z']))\n            print('')\n            print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%(pol,m.values['cable_delay0'],m.values['cable_delay1'],m.values['cable_delay2'],m.values['cable_delay3']))\n            print('cable_delays_%s_hesse = numpy.array([%f,%f,%f,%f])'%(pol,m.errors['cable_delay0'],m.errors['cable_delay1'],m.errors['cable_delay2'],m.errors['cable_delay3']))\n\n            print('Code completed.')\n            print('\\a')\n\n            if True:\n                #This code is intended to save the output configuration produced by this script. \n                initial_deploy_index = str(info.returnDefaultDeploy())\n                initial_origin, initial_antennas_physical, initial_antennas_phase_hpol, initial_antennas_phase_vpol, initial_cable_delays, initial_description = bcr.configReader(initial_deploy_index,return_description=True)\n\n                output_origin = initial_origin\n                output_antennas_physical = initial_antennas_physical\n                if pol == 'hpol':\n                    output_antennas_phase_hpol = output_antennas_phase\n                    output_antennas_phase_vpol = initial_antennas_phase_vpol\n                else:\n                    output_antennas_phase_hpol = initial_antennas_phase_hpol\n                    output_antennas_phase_vpol = output_antennas_phase\n\n                output_cable_delays = initial_cable_delays\n                output_cable_delays[pol] = resulting_cable_delays\n                output_description = 'Automatically generated description for a calibration starting from deploy_index: %s.  This config has updated %s values based on a calibration that was performed.  Initial description: %s'%(initial_deploy_index, pol, initial_description)\n\n                if len(os.path.split(initial_deploy_index)) == 2:\n                    json_path = initial_deploy_index\n                else:\n                    json_path = os.path.join(os.environ['BEACON_ANALYSIS_DIR'],'config','automatically_generated_config_0.json')\n                \n                with open('./antenna_position_minimization.py', \"r\") as this_file:\n                    #read whole file to a string\n                    script_string = this_file.read()\n\n                bcr.configWriter(json_path, output_origin, output_antennas_physical, output_antennas_phase_hpol, output_antennas_phase_vpol, output_cable_delays, description=output_description,update_latlonel=True,force_write=True, additional_text=script_string) #does not overwrite.\n\n        else:\n            chi2_fig = plt.figure()\n            chi2_fig.canvas.set_window_title('Initial Positions')\n            chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n            if 0 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant0_x, cm.am_hpol.initial_ant0_y, cm.am_hpol.initial_ant0_z,c='r',alpha=0.5, marker='$H$',label='Hpol Initial Ant0')\n            if 1 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant1_x, cm.am_hpol.initial_ant1_y, cm.am_hpol.initial_ant1_z,c='g',alpha=0.5, marker='$H$',label='Hpol Initial Ant1')\n            if 2 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant2_x, cm.am_hpol.initial_ant2_y, cm.am_hpol.initial_ant2_z,c='b',alpha=0.5, marker='$H$',label='Hpol Initial Ant2')\n            if 3 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant3_x, cm.am_hpol.initial_ant3_y, cm.am_hpol.initial_ant3_z,c='m',alpha=0.5, marker='$H$',label='Hpol Initial Ant3')\n\n            if 0 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant0_x, cm.am_vpol.initial_ant0_y, cm.am_vpol.initial_ant0_z,c='r',alpha=0.5, marker='$V$',label='Vpol Initial Ant0')\n            if 1 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant1_x, cm.am_vpol.initial_ant1_y, cm.am_vpol.initial_ant1_z,c='g',alpha=0.5, marker='$V$',label='Vpol Initial Ant1')\n            if 2 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant2_x, cm.am_vpol.initial_ant2_y, cm.am_vpol.initial_ant2_z,c='b',alpha=0.5, marker='$V$',label='Vpol Initial Ant2')\n            if 3 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant3_x, cm.am_vpol.initial_ant3_y, cm.am_vpol.initial_ant3_z,c='m',alpha=0.5, marker='$V$',label='Vpol Initial Ant3')\n\n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            \n            chi2_ax.dist = 10\n            plt.legend()\n\n            chi2_fig = plt.figure()\n            chi2_fig.canvas.set_window_title('Both')\n            chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n            if 0 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant0_x, cm.am_hpol.initial_ant0_y, cm.am_hpol.initial_ant0_z,c='r',alpha=0.5, marker='$H_i$',label='Hpol Initial Ant0')\n            if 1 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant1_x, cm.am_hpol.initial_ant1_y, cm.am_hpol.initial_ant1_z,c='g',alpha=0.5, marker='$H_i$',label='Hpol Initial Ant1')\n            if 2 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant2_x, cm.am_hpol.initial_ant2_y, cm.am_hpol.initial_ant2_z,c='b',alpha=0.5, marker='$H_i$',label='Hpol Initial Ant2')\n            if 3 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_hpol.initial_ant3_x, cm.am_hpol.initial_ant3_y, cm.am_hpol.initial_ant3_z,c='m',alpha=0.5, marker='$H_i$',label='Hpol Initial Ant3')\n\n            if 0 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant0_x, cm.am_vpol.initial_ant0_y, cm.am_vpol.initial_ant0_z,c='r',alpha=0.5, marker='$V_i$',label='Vpol Initial Ant0')\n            if 1 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant1_x, cm.am_vpol.initial_ant1_y, cm.am_vpol.initial_ant1_z,c='g',alpha=0.5, marker='$V_i$',label='Vpol Initial Ant1')\n            if 2 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant2_x, cm.am_vpol.initial_ant2_y, cm.am_vpol.initial_ant2_z,c='b',alpha=0.5, marker='$V_i$',label='Vpol Initial Ant2')\n            if 3 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(cm.am_vpol.initial_ant3_x, cm.am_vpol.initial_ant3_y, cm.am_vpol.initial_ant3_z,c='m',alpha=0.5, marker='$V_i$',label='Vpol Initial Ant3')\n\n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            \n            chi2_ax.dist = 10\n            plt.legend()\n\n            for antenna in range(4):\n                fig = plt.figure()\n                fig.canvas.set_window_title('Ant %i chi^2'%antenna)\n                for index, key in enumerate(['ant%i_x_hpol'%antenna,'ant%i_y_hpol'%antenna,'ant%i_z_hpol'%antenna]):\n                    plt.subplot(1,3,index + 1)\n                    m.draw_profile(key)\n\n            if cable_delay_guess_range is not None:\n                fig = plt.figure()\n                fig.canvas.set_window_title('HPol Cable Delays')\n                for antenna in range(4):\n                    plt.subplot(2,2,antenna + 1)\n                    m.draw_profile('cable_delay%i_hpol'%antenna)\n                fig = plt.figure()\n                fig.canvas.set_window_title('VPol Cable Delays')\n                for antenna in range(4):\n                    plt.subplot(2,2,antenna + 1)\n                    m.draw_profile('cable_delay%i_vpol'%antenna)\n\n            #12 variables\n            ant0_phase_x_hpol = m.values['ant0_x_hpol']\n            ant0_phase_x_vpol = cm.am_vpol.initial_ant0_x + ( ant0_phase_x_hpol - cm.am_hpol.initial_ant0_x )\n            ant0_phase_y_hpol = m.values['ant0_y_hpol']\n            ant0_phase_y_vpol = cm.am_vpol.initial_ant0_y + ( ant0_phase_y_hpol - cm.am_hpol.initial_ant0_y )\n            ant0_phase_z_hpol = m.values['ant0_z_hpol']\n            ant0_phase_z_vpol = cm.am_vpol.initial_ant0_z + ( ant0_phase_z_hpol - cm.am_hpol.initial_ant0_z )\n            ant0_cable_delay_hpol = m.values['cable_delay0_hpol']\n            ant0_cable_delay_vpol = m.values['cable_delay0_vpol']\n\n            ant1_phase_x_hpol = m.values['ant1_x_hpol']\n            ant1_phase_x_vpol = cm.am_vpol.initial_ant1_x + ( ant1_phase_x_hpol - cm.am_hpol.initial_ant1_x )\n            ant1_phase_y_hpol = m.values['ant1_y_hpol']\n            ant1_phase_y_vpol = cm.am_vpol.initial_ant1_y + ( ant1_phase_y_hpol - cm.am_hpol.initial_ant1_y )\n            ant1_phase_z_hpol = m.values['ant1_z_hpol']\n            ant1_phase_z_vpol = cm.am_vpol.initial_ant1_z + ( ant1_phase_z_hpol - cm.am_hpol.initial_ant1_z )\n            ant1_cable_delay_hpol = m.values['cable_delay1_hpol']\n            ant1_cable_delay_vpol = m.values['cable_delay1_vpol']\n\n            ant2_phase_x_hpol = m.values['ant2_x_hpol']\n            ant2_phase_x_vpol = cm.am_vpol.initial_ant2_x + ( ant2_phase_x_hpol - cm.am_hpol.initial_ant2_x )\n            ant2_phase_y_hpol = m.values['ant2_y_hpol']\n            ant2_phase_y_vpol = cm.am_vpol.initial_ant2_y + ( ant2_phase_y_hpol - cm.am_hpol.initial_ant2_y )\n            ant2_phase_z_hpol = m.values['ant2_z_hpol']\n            ant2_phase_z_vpol = cm.am_vpol.initial_ant2_z + ( ant2_phase_z_hpol - cm.am_hpol.initial_ant2_z )\n            ant2_cable_delay_hpol = m.values['cable_delay2_hpol']\n            ant2_cable_delay_vpol = m.values['cable_delay2_vpol']\n\n            ant3_phase_x_hpol = m.values['ant3_x_hpol']\n            ant3_phase_x_vpol = cm.am_vpol.initial_ant3_x + ( ant3_phase_x_hpol - cm.am_hpol.initial_ant3_x )\n            ant3_phase_y_hpol = m.values['ant3_y_hpol']\n            ant3_phase_y_vpol = cm.am_vpol.initial_ant3_y + ( ant3_phase_y_hpol - cm.am_hpol.initial_ant3_y )\n            ant3_phase_z_hpol = m.values['ant3_z_hpol']\n            ant3_phase_z_vpol = cm.am_vpol.initial_ant3_z + ( ant3_phase_z_hpol - cm.am_hpol.initial_ant3_z )\n            ant3_cable_delay_hpol = m.values['cable_delay3_hpol']\n            ant3_cable_delay_vpol = m.values['cable_delay3_vpol']\n\n            ant0_ENU_hpol = numpy.array([ant0_phase_x_hpol, ant0_phase_y_hpol, ant0_phase_z_hpol])\n            ant1_ENU_hpol = numpy.array([ant1_phase_x_hpol, ant1_phase_y_hpol, ant1_phase_z_hpol])\n            ant2_ENU_hpol = numpy.array([ant2_phase_x_hpol, ant2_phase_y_hpol, ant2_phase_z_hpol])\n            ant3_ENU_hpol = numpy.array([ant3_phase_x_hpol, ant3_phase_y_hpol, ant3_phase_z_hpol])\n            ant0_ENU_vpol = numpy.array([ant0_phase_x_vpol, ant0_phase_y_vpol, ant0_phase_z_vpol])\n            ant1_ENU_vpol = numpy.array([ant1_phase_x_vpol, ant1_phase_y_vpol, ant1_phase_z_vpol])\n            ant2_ENU_vpol = numpy.array([ant2_phase_x_vpol, ant2_phase_y_vpol, ant2_phase_z_vpol])\n            ant3_ENU_vpol = numpy.array([ant3_phase_x_vpol, ant3_phase_y_vpol, ant3_phase_z_vpol])\n            resulting_cable_delays_hpol = numpy.array([ant0_cable_delay_hpol,ant1_cable_delay_hpol,ant2_cable_delay_hpol,ant3_cable_delay_hpol])\n            resulting_cable_delays_vpol = numpy.array([ant0_cable_delay_vpol,ant1_cable_delay_vpol,ant2_cable_delay_vpol,ant3_cable_delay_vpol])\n\n            output_antennas_phase_hpol = {0:ant0_ENU_hpol, 1:ant1_ENU_hpol, 2:ant2_ENU_hpol, 3:ant3_ENU_hpol}\n            output_antennas_phase_vpol = {0:ant0_ENU_vpol, 1:ant1_ENU_vpol, 2:ant2_ENU_vpol, 3:ant3_ENU_vpol}\n\n            chi2_ax.plot([cm.am_hpol.initial_ant0_x , ant0_phase_x_hpol], [cm.am_hpol.initial_ant0_y , ant0_phase_y_hpol], [cm.am_hpol.initial_ant0_z , ant0_phase_z_hpol],c='r',alpha=0.5,linestyle='--')\n            chi2_ax.plot([cm.am_hpol.initial_ant1_x , ant1_phase_x_hpol], [cm.am_hpol.initial_ant1_y , ant1_phase_y_hpol], [cm.am_hpol.initial_ant1_z , ant1_phase_z_hpol],c='g',alpha=0.5,linestyle='--')\n            chi2_ax.plot([cm.am_hpol.initial_ant2_x , ant2_phase_x_hpol], [cm.am_hpol.initial_ant2_y , ant2_phase_y_hpol], [cm.am_hpol.initial_ant2_z , ant2_phase_z_hpol],c='b',alpha=0.5,linestyle='--')\n            chi2_ax.plot([cm.am_hpol.initial_ant3_x , ant3_phase_x_hpol], [cm.am_hpol.initial_ant3_y , ant3_phase_y_hpol], [cm.am_hpol.initial_ant3_z , ant3_phase_z_hpol],c='m',alpha=0.5,linestyle='--')\n\n            chi2_ax.scatter(ant0_phase_x_hpol, ant0_phase_y_hpol, ant0_phase_z_hpol,c='r',alpha=0.5,label='Hpol Final Ant0', marker='$H_f$')\n            chi2_ax.scatter(ant1_phase_x_hpol, ant1_phase_y_hpol, ant1_phase_z_hpol,c='g',alpha=0.5,label='Hpol Final Ant1', marker='$H_f$')\n            chi2_ax.scatter(ant2_phase_x_hpol, ant2_phase_y_hpol, ant2_phase_z_hpol,c='b',alpha=0.5,label='Hpol Final Ant2', marker='$H_f$')\n            chi2_ax.scatter(ant3_phase_x_hpol, ant3_phase_y_hpol, ant3_phase_z_hpol,c='m',alpha=0.5,label='Hpol Final Ant3', marker='$H_f$')\n\n            chi2_ax.plot([cm.am_vpol.initial_ant0_x , ant0_phase_x_vpol], [cm.am_vpol.initial_ant0_y , ant0_phase_y_vpol], [cm.am_vpol.initial_ant0_z , ant0_phase_z_vpol],c='r',alpha=0.5,linestyle='--')\n            chi2_ax.plot([cm.am_vpol.initial_ant1_x , ant1_phase_x_vpol], [cm.am_vpol.initial_ant1_y , ant1_phase_y_vpol], [cm.am_vpol.initial_ant1_z , ant1_phase_z_vpol],c='g',alpha=0.5,linestyle='--')\n            chi2_ax.plot([cm.am_vpol.initial_ant2_x , ant2_phase_x_vpol], [cm.am_vpol.initial_ant2_y , ant2_phase_y_vpol], [cm.am_vpol.initial_ant2_z , ant2_phase_z_vpol],c='b',alpha=0.5,linestyle='--')\n            chi2_ax.plot([cm.am_vpol.initial_ant3_x , ant3_phase_x_vpol], [cm.am_vpol.initial_ant3_y , ant3_phase_y_vpol], [cm.am_vpol.initial_ant3_z , ant3_phase_z_vpol],c='m',alpha=0.5,linestyle='--')\n\n            chi2_ax.scatter(ant0_phase_x_vpol, ant0_phase_y_vpol, ant0_phase_z_vpol,c='r',alpha=0.5,label='Vpol Final Ant0', marker='$H_f$')\n            chi2_ax.scatter(ant1_phase_x_vpol, ant1_phase_y_vpol, ant1_phase_z_vpol,c='g',alpha=0.5,label='Vpol Final Ant1', marker='$H_f$')\n            chi2_ax.scatter(ant2_phase_x_vpol, ant2_phase_y_vpol, ant2_phase_z_vpol,c='b',alpha=0.5,label='Vpol Final Ant2', marker='$H_f$')\n            chi2_ax.scatter(ant3_phase_x_vpol, ant3_phase_y_vpol, ant3_phase_z_vpol,c='m',alpha=0.5,label='Vpol Final Ant3', marker='$H_f$')\n            \n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            chi2_ax.dist = 10\n            plt.legend()\n\n\n\n            chi2_fig = plt.figure()\n            chi2_fig.canvas.set_window_title('Final Positions')\n            chi2_ax = chi2_fig.add_subplot(111, projection='3d')\n            if 0 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(ant0_phase_x_hpol, ant0_phase_y_hpol, ant0_phase_z_hpol,marker='$H$',c='r',alpha=0.5,label='Hpol Final Ant0')\n            if 1 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(ant1_phase_x_hpol, ant1_phase_y_hpol, ant1_phase_z_hpol,marker='$H$',c='g',alpha=0.5,label='Hpol Final Ant1')\n            if 2 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(ant2_phase_x_hpol, ant2_phase_y_hpol, ant2_phase_z_hpol,marker='$H$',c='b',alpha=0.5,label='Hpol Final Ant2')\n            if 3 in cm.am_hpol.included_antennas_lumped:\n                chi2_ax.scatter(ant3_phase_x_hpol, ant3_phase_y_hpol, ant3_phase_z_hpol,marker='$H$',c='m',alpha=0.5,label='Hpol Final Ant3')\n            if 0 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(ant0_phase_x_vpol, ant0_phase_y_vpol, ant0_phase_z_vpol,marker='$V$',c='r',alpha=0.5,label='Vpol Final Ant0')\n            if 1 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(ant1_phase_x_vpol, ant1_phase_y_vpol, ant1_phase_z_vpol,marker='$V$',c='g',alpha=0.5,label='Vpol Final Ant1')\n            if 2 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(ant2_phase_x_vpol, ant2_phase_y_vpol, ant2_phase_z_vpol,marker='$V$',c='b',alpha=0.5,label='Vpol Final Ant2')\n            if 3 in cm.am_vpol.included_antennas_lumped:\n                chi2_ax.scatter(ant3_phase_x_vpol, ant3_phase_y_vpol, ant3_phase_z_vpol,marker='$V$',c='m',alpha=0.5,label='Vpol Final Ant3')\n\n            chi2_ax.set_xlabel('East (m)',linespacing=10)\n            chi2_ax.set_ylabel('North (m)',linespacing=10)\n            chi2_ax.set_zlabel('Up (m)',linespacing=10)\n            chi2_ax.dist = 10\n            plt.legend()\n\n            #Plot Pulser Events\n            pulser_info = PulserInfo()\n            for _pol in ['hpol','vpol']:\n                for key in ['d2sa','d3sa','d3sb','d3sc','d4sa','d4sb']:\n                    #Calculate old and new geometries\n                    #Distance needed when calling correlator, as it uses that distance.\n                    if _pol == 'hpol':\n                        original_pulser_ENU = numpy.array([cm.am_hpol.pulser_locations_ENU[key][0] , cm.am_hpol.pulser_locations_ENU[key][1] , cm.am_hpol.pulser_locations_ENU[key][2]])\n                    else:\n                        original_pulser_ENU = numpy.array([cm.am_vpol.pulser_locations_ENU[key][0] , cm.am_vpol.pulser_locations_ENU[key][1] , cm.am_vpol.pulser_locations_ENU[key][2]])\n\n                    original_distance_m = numpy.linalg.norm(original_pulser_ENU)\n                    original_zenith_deg = numpy.rad2deg(numpy.arccos(original_pulser_ENU[2]/original_distance_m))\n                    original_elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(original_pulser_ENU[2]/original_distance_m))\n                    original_azimuth_deg = numpy.rad2deg(numpy.arctan2(original_pulser_ENU[1],original_pulser_ENU[0]))\n\n                    if _pol == 'hpol':\n                        pulser_ENU_new = numpy.array([cm.am_hpol.pulser_locations_ENU[key][0] - ant0_ENU_hpol[0] , cm.am_hpol.pulser_locations_ENU[key][1] - ant0_ENU_hpol[1] , cm.am_hpol.pulser_locations_ENU[key][2] - ant0_ENU_hpol[2]])\n                    else:\n                        pulser_ENU_new = numpy.array([cm.am_vpol.pulser_locations_ENU[key][0] - ant0_ENU_vpol[0] , cm.am_vpol.pulser_locations_ENU[key][1] - ant0_ENU_vpol[1] , cm.am_vpol.pulser_locations_ENU[key][2] - ant0_ENU_vpol[2]])\n                    distance_m = numpy.linalg.norm(pulser_ENU_new)\n                    zenith_deg = numpy.rad2deg(numpy.arccos(pulser_ENU_new[2]/distance_m))\n                    elevation_deg = 90.0 - numpy.rad2deg(numpy.arccos(pulser_ENU_new[2]/distance_m))\n                    azimuth_deg = numpy.rad2deg(numpy.arctan2(pulser_ENU_new[1],pulser_ENU_new[0]))\n\n                    map_resolution = 0.25 #degrees\n                    range_phi_deg = (-90, 90)\n                    range_theta_deg = (80,120)\n                    n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                    n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                    \n\n                    known_pulser_ids = info.load2021PulserEventids()[key][_pol]\n                    known_pulser_ids = known_pulser_ids[numpy.isin(known_pulser_ids['attenuation_dB'], attenuations_dict[_pol][key])]\n                    reference_event  = pulser_info.getPulserReferenceEvent(key, _pol)\n                    if True:\n                        event_info = reference_event\n                    else:\n                        event_info = numpy.random.choice(known_pulser_ids)\n\n                    reader = Reader(datapath,int(event_info['run']))\n                    \n                    cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                    cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cm.am_hpol.initial_ant0_ENU,cm.am_hpol.initial_ant1_ENU,cm.am_hpol.initial_ant2_ENU,cm.am_hpol.initial_ant3_ENU,cm.am_vpol.initial_ant0_ENU,cm.am_vpol.initial_ant1_ENU,cm.am_vpol.initial_ant2_ENU,cm.am_vpol.initial_ant3_ENU,verbose=False)\n                   \n                    adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                    adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                    adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU_hpol,ant1_ENU_hpol,ant2_ENU_hpol,ant3_ENU_hpol,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                    adjusted_cor.overwriteCableDelays(m.values['cable_delay0_hpol'], m.values['cable_delay0_vpol'], m.values['cable_delay1_hpol'], m.values['cable_delay1_vpol'], m.values['cable_delay2_hpol'], m.values['cable_delay2_vpol'], m.values['cable_delay3_hpol'], m.values['cable_delay3_vpol'])\n\n                    if plot_expected_direction == False:\n                        zenith_deg = None\n                        azimuth_deg = None\n\n                    if plot_time_delays_on_maps:\n                        td_dict = {}\n                        if False:\n                            #Good for troubleshooting if a cycle slipped.\n                            cycle_slip_estimate_ns = 15\n                            n_cycles = 1\n                            td_dict[_pol] = {'[0, 1]' :  measured_time_delays[key][_pol]['delays_ns'][0] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[0, 2]' : measured_time_delays[key][_pol]['delays_ns'][1] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[0, 3]' : measured_time_delays[key][_pol]['delays_ns'][2] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[1, 2]' : measured_time_delays[key][_pol]['delays_ns'][3] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[1, 3]' : measured_time_delays[key][_pol]['delays_ns'][4] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns, '[2, 3]' : measured_time_delays[key][_pol]['delays_ns'][5] + numpy.arange(-n_cycles, n_cycles + 1)*cycle_slip_estimate_ns}\n                        else:\n                            td_dict[_pol] = {'[0, 1]' :  [measured_time_delays[key][_pol]['delays_ns'][0]], '[0, 2]' : [measured_time_delays[key][_pol]['delays_ns'][1]], '[0, 3]' : [measured_time_delays[key][_pol]['delays_ns'][2]], '[1, 2]' : [measured_time_delays[key][_pol]['delays_ns'][3]], '[1, 3]' : [measured_time_delays[key][_pol]['delays_ns'][4]], '[2, 3]' : [measured_time_delays[key][_pol]['delays_ns'][5]]}\n                    else:\n                        td_dict = {}\n\n\n                    #mean_corr_values, fig, ax = cor.map(int(event_info['eventid']), pol, include_baselines=include_baselines, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict,shorten_signals=shorten_signals, shorten_thresh=shorten_thresh, shorten_delay=shorten_delay, shorten_length=shorten_length, shorten_keep_leading=shorten_keep_leading)\n                    adjusted_mean_corr_values, adjusted_fig, adjusted_ax = adjusted_cor.map(int(event_info['eventid']), _pol, include_baselines=include_baselines, plot_map=True, plot_corr=False, hilbert=False, radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90], interactive=True,circle_zenith=zenith_deg, circle_az=azimuth_deg, time_delay_dict=td_dict,shorten_signals=shorten_signals, shorten_thresh=shorten_thresh, shorten_delay=shorten_delay, shorten_length=shorten_length, shorten_keep_leading=shorten_keep_leading)\n                    adjusted_fig.set_size_inches(16, 9)\n                    plt.sca(adjusted_ax)\n                    plt.tight_layout()\n                    adjusted_fig.savefig('./%s.png'%key,dpi=90)\n\n                    if plot_histograms:\n                        map_resolution = 0.1 #degrees\n                        range_phi_deg=(azimuth_deg - 10, azimuth_deg + 10)\n                        range_theta_deg=(zenith_deg - 10,zenith_deg + 10)\n                        n_phi = numpy.ceil((max(range_phi_deg) - min(range_phi_deg))/map_resolution).astype(int)\n                        n_theta = numpy.ceil((max(range_theta_deg) - min(range_theta_deg))/map_resolution).astype(int)\n                                        \n                        cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=original_distance_m)\n                        cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                        cor.overwriteAntennaLocations(cor.A0_physical,cor.A1_physical,cor.A2_physical,cor.A3_physical,cm.am_hpol.initial_ant0_ENU,cm.am_hpol.initial_ant1_ENU,cm.am_hpol.initial_ant2_ENU,cm.am_hpol.initial_ant3_ENU,cm.am_vpol.initial_ant0_ENU,cm.am_vpol.initial_ant1_ENU,cm.am_vpol.initial_ant2_ENU,cm.am_vpol.initial_ant3_ENU,verbose=False)\n\n                        adjusted_cor = Correlator(reader,  upsample=cor_upsample, n_phi=n_phi,range_phi_deg=range_phi_deg, n_theta=n_theta,range_theta_deg=range_theta_deg, waveform_index_range=(None,None),crit_freq_low_pass_MHz=crit_freq_low_pass_MHz, crit_freq_high_pass_MHz=crit_freq_high_pass_MHz, low_pass_filter_order=low_pass_filter_order, high_pass_filter_order=high_pass_filter_order, plot_filter=False,apply_phase_response=apply_phase_response, tukey=False, sine_subtract=True,map_source_distance_m=distance_m)\n                        adjusted_cor.prep.addSineSubtract(sine_subtract_min_freq_GHz, sine_subtract_max_freq_GHz, sine_subtract_percent, max_failed_iterations=3, verbose=False, plot=False)\n\n                        adjusted_cor.overwriteAntennaLocations(adjusted_cor.A0_physical,adjusted_cor.A1_physical,adjusted_cor.A2_physical,adjusted_cor.A3_physical,ant0_ENU_hpol,ant1_ENU_hpol,ant2_ENU_hpol,ant3_ENU_hpol,adjusted_cor.A0_vpol,adjusted_cor.A1_vpol,adjusted_cor.A2_vpol,adjusted_cor.A3_vpol,verbose=False)\n                        adjusted_cor.overwriteCableDelays(m.values['cable_delay0_hpol'], m.values['cable_delay0_vpol'], m.values['cable_delay1_hpol'], m.values['cable_delay1_vpol'], m.values['cable_delay2_hpol'], m.values['cable_delay2_vpol'], m.values['cable_delay3_hpol'], m.values['cable_delay3_vpol'])\n                        \n                        run_cut = known_pulser_ids['run'] == reader.run #Make sure all eventids in same run\n                        hist = adjusted_cor.histMapPeak(numpy.sort(numpy.random.choice(known_pulser_ids[run_cut],min(limit_events,len(known_pulser_ids[run_cut]))))['eventid'], _pol, plot_map=True, hilbert=False, max_method=0, use_weight=False, mollweide=False, center_dir='E', radius=1.0,zenith_cut_ENU=[90,180],zenith_cut_array_plane=[0,90],circle_zenith=zenith_deg, circle_az=azimuth_deg, window_title='Hist ' + key, include_baselines=include_baselines,iterate_sub_baselines=iterate_sub_baselines)\n\n            # Finalized Output \n\n            print('Estimated degrees of freedom: %i'%sum([not v for k, v in m.fixed.items()]))\n            print('Estimated input measured values: %i'%(len(cm.am_hpol.include_baselines)*len(cm.am_hpol.use_sites) + len(cm.am_hpol.include_baselines)*len(cm.am_hpol.use_sites) + len(cm.am_vpol.include_baselines)*len(cm.am_vpol.use_sites) + len(cm.am_vpol.include_baselines)*len(cm.am_vpol.use_sites)))\n\n\n            print('\\n')\n            print('STARTING CONDITION INPUT VALUES HERE')\n            print('\\n')\n            print('')\n\n            print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%('hpol', cm.am_hpol.initial_ant0_x,cm.am_hpol.initial_ant0_y,cm.am_hpol.initial_ant0_z ,  cm.am_hpol.initial_ant1_x,cm.am_hpol.initial_ant1_y,cm.am_hpol.initial_ant1_z,  cm.am_hpol.initial_ant2_x,cm.am_hpol.initial_ant2_y,cm.am_hpol.initial_ant2_z,  cm.am_hpol.initial_ant3_x,cm.am_hpol.initial_ant3_y,cm.am_hpol.initial_ant3_z))\n            print('')\n            print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%('hpol',cm.am_hpol.cable_delays[0],cm.am_hpol.cable_delays[1],cm.am_hpol.cable_delays[2],cm.am_hpol.cable_delays[3]))\n\n            print('\\n')\n            print(result)\n            print('\\n')\n            print('Copy-Paste Prints:\\n------------')\n            print('')\n\n            print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%('hpol', ant0_ENU_hpol[0] , ant0_ENU_hpol[1] , ant0_ENU_hpol[2] , ant1_ENU_hpol[0] , ant1_ENU_hpol[1] , ant1_ENU_hpol[2],  ant2_ENU_hpol[0] , ant2_ENU_hpol[1] , ant2_ENU_hpol[2],  ant3_ENU_hpol[0] , ant3_ENU_hpol[1] , ant3_ENU_hpol[2]))\n            print('antennas_phase_%s_hesse = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%('hpol', m.errors['ant0_x_hpol'],m.errors['ant0_y_hpol'],m.errors['ant0_z_hpol'] ,  m.errors['ant1_x_hpol'],m.errors['ant1_y_hpol'],m.errors['ant1_z_hpol'],  m.errors['ant2_x_hpol'],m.errors['ant2_y_hpol'],m.errors['ant2_z_hpol'],  m.errors['ant3_x_hpol'],m.errors['ant3_y_hpol'],m.errors['ant3_z_hpol']))\n            print('')\n            print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%('hpol',m.values['cable_delay0_hpol'],m.values['cable_delay1_hpol'],m.values['cable_delay2_hpol'],m.values['cable_delay3_hpol']))\n            print('cable_delays_%s_hesse = numpy.array([%f,%f,%f,%f])'%('hpol',m.errors['cable_delay0_hpol'],m.errors['cable_delay1_hpol'],m.errors['cable_delay2_hpol'],m.errors['cable_delay3_hpol']))\n\n\n\n            print('\\n')\n            print('STARTING CONDITION INPUT VALUES HERE')\n            print('\\n')\n            print('')\n\n            print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%('vpol', cm.am_vpol.initial_ant0_x,cm.am_vpol.initial_ant0_y,cm.am_vpol.initial_ant0_z ,  cm.am_vpol.initial_ant1_x,cm.am_vpol.initial_ant1_y,cm.am_vpol.initial_ant1_z,  cm.am_vpol.initial_ant2_x,cm.am_vpol.initial_ant2_y,cm.am_vpol.initial_ant2_z,  cm.am_vpol.initial_ant3_x,cm.am_vpol.initial_ant3_y,cm.am_vpol.initial_ant3_z))\n            print('')\n            print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%('vpol',cm.am_vpol.cable_delays[0],cm.am_vpol.cable_delays[1],cm.am_vpol.cable_delays[2],cm.am_vpol.cable_delays[3]))\n\n            print('\\n')\n            print(result)\n            print('\\n')\n            print('Copy-Paste Prints:\\n------------')\n            print('')\n\n            print('antennas_phase_%s = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%('vpol', ant0_ENU_vpol[0] , ant0_ENU_vpol[1] , ant0_ENU_vpol[2] , ant1_ENU_vpol[0] , ant1_ENU_vpol[1] , ant1_ENU_vpol[2],  ant2_ENU_vpol[0] , ant2_ENU_vpol[1] , ant2_ENU_vpol[2],  ant3_ENU_vpol[0] , ant3_ENU_vpol[1] , ant3_ENU_vpol[2]))\n            print('antennas_phase_%s_hesse = {0 : [%f, %f, %f], 1 : [%f, %f, %f], 2 : [%f, %f, %f], 3 : [%f, %f, %f]}'%('vpol', m.errors['ant0_x_hpol'],m.errors['ant0_y_hpol'],m.errors['ant0_z_hpol'] ,  m.errors['ant1_x_hpol'],m.errors['ant1_y_hpol'],m.errors['ant1_z_hpol'],  m.errors['ant2_x_hpol'],m.errors['ant2_y_hpol'],m.errors['ant2_z_hpol'],  m.errors['ant3_x_hpol'],m.errors['ant3_y_hpol'],m.errors['ant3_z_hpol'])) #Hpol errors because vpol don't move independently\n            print('')\n            print('cable_delays_%s = numpy.array([%f,%f,%f,%f])'%('vpol',m.values['cable_delay0_vpol'],m.values['cable_delay1_vpol'],m.values['cable_delay2_vpol'],m.values['cable_delay3_vpol']))\n            print('cable_delays_%s_hesse = numpy.array([%f,%f,%f,%f])'%('vpol',m.errors['cable_delay0_vpol'],m.errors['cable_delay1_vpol'],m.errors['cable_delay2_vpol'],m.errors['cable_delay3_vpol']))\n\n\n            print('Code completed.')\n            print('\\a')\n\n            if True:\n                #This code is intended to save the output configuration produced by this script. \n                initial_deploy_index = str(info.returnDefaultDeploy())\n                initial_origin, initial_antennas_physical, initial_antennas_phase_hpol, initial_antennas_phase_vpol, initial_cable_delays, initial_description = bcr.configReader(initial_deploy_index,return_description=True)\n\n                output_origin = initial_origin\n                output_antennas_physical = initial_antennas_physical\n                output_antennas_phase_hpol = output_antennas_phase_hpol\n                output_antennas_phase_vpol = output_antennas_phase_vpol\n\n                output_cable_delays = {}\n                output_cable_delays['hpol'] = resulting_cable_delays_hpol\n                output_cable_delays['vpol'] = resulting_cable_delays_vpol\n                output_description = 'Automatically generated description for a calibration starting from deploy_index: %s.  This config has updated %s values based on a calibration that was performed.  Initial description: %s'%(initial_deploy_index, pol, initial_description)\n\n                if len(os.path.split(initial_deploy_index)) == 2:\n                    json_path = initial_deploy_index\n                else:\n                    json_path = os.path.join(os.environ['BEACON_ANALYSIS_DIR'],'config','automatically_generated_config_0.json')\n                \n                with open('./antenna_position_minimization.py', \"r\") as this_file:\n                    #read whole file to a string\n                    script_string = this_file.read()\n\n                bcr.configWriter(json_path, output_origin, output_antennas_physical, output_antennas_phase_hpol, output_antennas_phase_vpol, output_cable_delays, description=output_description,update_latlonel=True,force_write=True, additional_text=script_string) #does not overwrite.\n\n\n\n\n\n\n            \n    except Exception as e:\n        print('Error in main loop.')\n        print(e)\n        exc_type, exc_obj, exc_tb = sys.exc_info()\n        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n        print(exc_type, fname, exc_tb.tb_lineno)\n\n\n\n\n\n\n",
    "origin": {
        "latlonel": [
            37.589339,
            -118.23761867,
            3850.5272
        ]
    },
    "antennas": {
        "ant0": {
            "physical": {
                "latlonel": [
                    37.589339,
                    -118.23761867,
                    3850.5272
                ],
                "enu": [
                    0.0,
                    0.0,
                    0.0
                ]
            },
            "hpol": {
                "latlonel": [
                    37.589339,
                    -118.23761867,
                    3850.5272
                ],
                "enu": [
                    0.0,
                    0.0,
                    0.0
                ],
                "cable_delay": 462.5927,
                "channel": 0
            },
            "vpol": {
                "latlonel": [
                    37.589339,
                    -118.23761867,
                    3850.5272
                ],
                "enu": [
                    0.0,
                    0.0,
                    0.0
                ],
                "cable_delay": 459.1555,
                "channel": 1
            }
        },
        "ant1": {
            "physical": {
                "latlonel": [
                    37.58922017,
                    -118.238006,
                    3865.1272
                ],
                "enu": [
                    -34.229739100497184,
                    -13.196735088178848,
                    14.599894634214646
                ]
            },
            "hpol": {
                "latlonel": [
                    37.58922667,
                    -118.23797536,
                    3869.09732465
                ],
                "enu": [
                    -31.522254448651225,
                    -12.474656104236148,
                    18.570034667958893
                ],
                "cable_delay": 471.9734439655478,
                "channel": 2
            },
            "vpol": {
                "latlonel": [
                    37.58922886,
                    -118.237954,
                    3870.56250024
                ],
                "enu": [
                    -29.63428485514641,
                    -12.231783732534206,
                    20.035219766777814
                ],
                "cable_delay": 479.2270338249415,
                "channel": 3
            }
        },
        "ant2": {
            "physical": {
                "latlonel": [
                    37.58889833,
                    -118.23769983,
                    3854.3272
                ],
                "enu": [
                    -7.172418589601591,
                    -48.93903858128436,
                    3.799807775379783
                ]
            },
            "hpol": {
                "latlonel": [
                    37.58890914,
                    -118.23766025,
                    3857.71074227
                ],
                "enu": [
                    -3.674731044480198,
                    -47.73836548921845,
                    7.1833621339415155
                ],
                "cable_delay": 462.70854757902254,
                "channel": 4
            },
            "vpol": {
                "latlonel": [
                    37.58891174,
                    -118.23765275,
                    3855.83619533
                ],
                "enu": [
                    -3.0118970175625557,
                    -47.44974451980192,
                    5.308817701831832
                ],
                "cable_delay": 475.28726388852726,
                "channel": 5
            }
        },
        "ant3": {
            "physical": {
                "latlonel": [
                    37.588943,
                    -118.23796567,
                    3864.3272
                ],
                "enu": [
                    -30.665742457535302,
                    -43.978183388828505,
                    13.799774438470354
                ]
            },
            "hpol": {
                "latlonel": [
                    37.5889594,
                    -118.23790611,
                    3869.80529951
                ],
                "enu": [
                    -25.402542738922893,
                    -42.15644463597101,
                    19.277909367351935
                ],
                "cable_delay": 474.7735758107436,
                "channel": 6
            },
            "vpol": {
                "latlonel": [
                    37.58896299,
                    -118.23789903,
                    3867.28189332
                ],
                "enu": [
                    -24.776587978559853,
                    -41.75857601060009,
                    16.754508262323338
                ],
                "cable_delay": 479.2217189171316,
                "channel": 7
            }
        }
    }
}